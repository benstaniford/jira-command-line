#!/usr/bin/python3

import curses
import datetime
from typing import Dict, List, Any, Optional
from libs.MyJira import MyJira
from libs.MyGithub import MyGithub
from libs.MyJiraConfig import MyJiraConfig
from git import Repo
import os
import tempfile
import threading
from pycopilot import CopilotClient, AuthCache, CopilotAuth

# Users to track
TRACKED_USERS = [
    {"email": "ncrowley@beyondtrust.com", "display": "Nick Crowley", "initials": "nc"},
    {"email": "nwicker@beyondtrust.com", "display": "Neil Wicker", "initials": "nw"},
    {"email": "tvarady@beyondtrust.com", "display": "Tamas Varady", "initials": "tv"},
    {"email": "jstephenson@beyondtrust.com", "display": "Josh Stephenson", "initials": "js"}
]
GIT_REPO_PATH = os.path.expanduser("~/Code/epm-windows")

class DashboardPane:
    """Represents a single pane in the dashboard"""
    def __init__(self, window, title: str):
        self.window = window
        self.title = title
        self.lines: List[str] = []
        self.scroll_offset = 0
        self.is_selected = False
        self.selection_start = None  # (line, col) tuple
        self.selection_end = None    # (line, col) tuple
        self.is_selecting = False

    def add_line(self, text: str):
        """Add a line of text to the pane"""
        self.lines.append(text)

    def clear(self):
        """Clear all lines"""
        self.lines = []
        self.scroll_offset = 0

    def scroll_up(self):
        """Scroll up by one line"""
        if self.scroll_offset > 0:
            self.scroll_offset -= 1

    def scroll_down(self):
        """Scroll down by one line"""
        h, w = self.window.getmaxyx()
        max_visible = h - 2  # Account for borders
        if self.scroll_offset + max_visible < len(self.lines):
            self.scroll_offset += 1

    def page_up(self):
        """Scroll up by one page"""
        h, w = self.window.getmaxyx()
        page_size = h - 2
        self.scroll_offset = max(0, self.scroll_offset - page_size)

    def page_down(self):
        """Scroll down by one page"""
        h, w = self.window.getmaxyx()
        page_size = h - 2
        max_offset = max(0, len(self.lines) - page_size)
        self.scroll_offset = min(max_offset, self.scroll_offset + page_size)

    def contains_point(self, y: int, x: int) -> bool:
        """Check if a point (y, x) is within this pane"""
        pane_y, pane_x = self.window.getbegyx()
        pane_h, pane_w = self.window.getmaxyx()
        return (pane_y <= y < pane_y + pane_h and
                pane_x <= x < pane_x + pane_w)

    def get_line_col_from_point(self, y: int, x: int) -> Optional[tuple]:
        """Convert screen coordinates to (line, col) within pane content"""
        pane_y, pane_x = self.window.getbegyx()
        pane_h, pane_w = self.window.getmaxyx()

        # Calculate relative position within pane
        rel_y = y - pane_y - 1  # -1 for border
        rel_x = x - pane_x - 1  # -1 for border

        # Check if within content area
        if rel_y < 0 or rel_y >= pane_h - 2 or rel_x < 0 or rel_x >= pane_w - 2:
            return None

        # Calculate actual line number with scroll offset
        line = self.scroll_offset + rel_y

        # Check if line exists
        if line >= len(self.lines):
            return None

        return (line, rel_x)

    def start_selection(self, y: int, x: int):
        """Start text selection at given screen coordinates"""
        pos = self.get_line_col_from_point(y, x)
        if pos:
            self.selection_start = pos
            self.selection_end = pos
            self.is_selecting = True

    def update_selection(self, y: int, x: int):
        """Update selection end point"""
        if self.is_selecting:
            pos = self.get_line_col_from_point(y, x)
            if pos:
                self.selection_end = pos

    def end_selection(self):
        """End selection"""
        self.is_selecting = False

    def clear_selection(self):
        """Clear the current selection"""
        self.selection_start = None
        self.selection_end = None
        self.is_selecting = False

    def get_selected_text(self) -> str:
        """Get the currently selected text"""
        if not self.selection_start or not self.selection_end:
            return ""

        start_line, start_col = self.selection_start
        end_line, end_col = self.selection_end

        # Ensure start is before end
        if start_line > end_line or (start_line == end_line and start_col > end_col):
            start_line, start_col, end_line, end_col = end_line, end_col, start_line, start_col

        selected_text = []

        if start_line == end_line:
            # Single line selection
            line_text = self.lines[start_line]
            selected_text.append(line_text[start_col:end_col + 1])
        else:
            # Multi-line selection
            # First line
            selected_text.append(self.lines[start_line][start_col:])

            # Middle lines
            for line_num in range(start_line + 1, end_line):
                if line_num < len(self.lines):
                    selected_text.append(self.lines[line_num])

            # Last line
            if end_line < len(self.lines):
                selected_text.append(self.lines[end_line][:end_col + 1])

        return '\n'.join(selected_text)

    def render(self):
        """Render the pane content"""
        self.window.clear()
        h, w = self.window.getmaxyx()

        # Draw border (highlighted if selected)
        if self.is_selected:
            self.window.attron(curses.A_BOLD)
            self.window.box()
            self.window.attroff(curses.A_BOLD)
        else:
            self.window.box()

        # Draw title
        title_text = f" {self.title} "
        if self.is_selected:
            title_text += "[ACTIVE] "
        self.window.addstr(0, 2, title_text, curses.A_BOLD)

        # Show scroll indicator if needed
        if len(self.lines) > h - 2:
            scroll_info = f" [{self.scroll_offset + 1}-{min(self.scroll_offset + h - 2, len(self.lines))}/{len(self.lines)}] "
            try:
                self.window.addstr(0, w - len(scroll_info) - 2, scroll_info)
            except:
                pass

        # Draw content with scroll offset and selection highlighting
        y = 1
        for i, line in enumerate(self.lines[self.scroll_offset:]):
            if y >= h - 1:  # Leave space for bottom border
                break

            line_num = self.scroll_offset + i
            display_line = line[:w-3] if len(line) > w-3 else line

            # Check if this line has selection
            if self.selection_start and self.selection_end:
                start_line, start_col = self.selection_start
                end_line, end_col = self.selection_end

                # Normalize selection (ensure start is before end)
                if start_line > end_line or (start_line == end_line and start_col > end_col):
                    start_line, start_col, end_line, end_col = end_line, end_col, start_line, start_col

                # Check if current line is in selection range
                if start_line <= line_num <= end_line:
                    # Determine selection range for this line
                    sel_start = 0
                    sel_end = len(display_line)

                    if line_num == start_line:
                        sel_start = start_col
                    if line_num == end_line:
                        sel_end = min(end_col + 1, len(display_line))

                    # Draw line with selection highlighting
                    try:
                        x_pos = 1
                        # Before selection
                        if sel_start > 0:
                            self.window.addstr(y, x_pos, display_line[:sel_start])
                            x_pos += sel_start

                        # Selection
                        if sel_start < sel_end:
                            selected_part = display_line[sel_start:sel_end]
                            self.window.addstr(y, x_pos, selected_part, curses.A_REVERSE)
                            x_pos += len(selected_part)

                        # After selection
                        if sel_end < len(display_line):
                            self.window.addstr(y, x_pos, display_line[sel_end:])
                    except:
                        pass
                else:
                    # No selection on this line
                    try:
                        self.window.addstr(y, 1, display_line)
                    except:
                        pass
            else:
                # No selection at all
                try:
                    self.window.addstr(y, 1, display_line)
                except:
                    pass

            y += 1

        self.window.refresh()


class Dashboard:
    """Main dashboard class"""
    def __init__(self, stdscr):
        self.stdscr = stdscr
        curses.curs_set(0)  # Hide cursor

        # Enable mouse events - need ALL_MOUSE_EVENTS for drag selection
        # We'll filter out unwanted events in the handler to avoid constant redraws
        curses.mousemask(curses.ALL_MOUSE_EVENTS)

        # Load config and initialize services
        config_file = MyJiraConfig()
        if not config_file.exists():
            raise Exception("Configuration file not found. Run main jira script first.")

        config = config_file.load()
        self.jira = MyJira(config.get('jira'))
        self.mygithub = MyGithub(config.get('github')) if config.get('github')['token'] != "" else None

        # Set up panes
        self.panes: List[DashboardPane] = []
        self.selected_pane = 0  # Index of currently selected pane
        self._create_panes()

    def _create_panes(self):
        """Create the 4 panes in a 2x2 grid"""
        height, width = self.stdscr.getmaxyx()

        # Calculate pane dimensions
        pane_height = height // 2
        pane_width = width // 2

        # Create windows for each pane, one per user
        positions = [
            (0, 0),  # Top-left
            (0, pane_width),  # Top-right
            (pane_height, 0),  # Bottom-left
            (pane_height, pane_width)  # Bottom-right
        ]

        sizes = [
            (pane_height, pane_width),  # Top-left
            (pane_height, width - pane_width),  # Top-right
            (height - pane_height, pane_width),  # Bottom-left
            (height - pane_height, width - pane_width)  # Bottom-right
        ]

        for i, user_info in enumerate(TRACKED_USERS):
            h, w = sizes[i]
            y, x = positions[i]
            win = curses.newwin(h, w, y, x)
            pane = DashboardPane(win, f"{user_info['display']} - Last 24h")
            pane.user_info = user_info  # Store user info in pane
            self.panes.append(pane)

    def get_user_stats(self, user_info: Dict[str, str]) -> Dict[str, Any]:
        """Gather statistics about a user from various sources"""
        user_email = user_info['email']
        user_initials = user_info['initials']

        stats = {
            'tickets': [],
            'commits': 0,
            'branches': [],
            'lines_added': 0,
            'lines_removed': 0,
            'prs': []
        }

        # Get Jira tickets assigned to user (excluding Done, Won't Do, New, Approved, and stale items)
        try:
            query = f'assignee = "{user_email}" AND status not in (Done, Closed, New, Approved, "Won\'t Do") AND updated >= -15d ORDER BY updated DESC'
            issues = self.jira.search_issues(query)

            for issue in issues:  # Show all matching tickets
                # Calculate how long since last update
                updated = datetime.datetime.strptime(issue.fields.updated[:19], '%Y-%m-%dT%H:%M:%S')
                days_since_update = (datetime.datetime.now() - updated).days

                # Skip items not modified in more than 15 days (double-check filter)
                if days_since_update > 15:
                    continue

                stats['tickets'].append({
                    'key': issue.key,
                    'summary': issue.fields.summary,
                    'status': str(issue.fields.status),
                    'days': days_since_update,
                    'url': issue.permalink()
                })
        except Exception as e:
            stats['tickets_error'] = str(e)

        # Get Git stats from the last 24 hours from user's branches on origin
        try:
            if os.path.exists(GIT_REPO_PATH):
                repo = Repo(GIT_REPO_PATH)
                yesterday = datetime.datetime.now() - datetime.timedelta(days=1)

                # Find all origin branches that start with user's initials
                user_branches = []
                try:
                    all_branches = repo.git.branch('-r').split('\n')
                    for branch in all_branches:
                        branch = branch.strip()
                        # Look for origin/{initials}/ branches
                        if branch.startswith(f'origin/{user_initials}/'):
                            user_branches.append(branch)
                except:
                    pass

                # Collect commits from user's branches
                user_commits = []
                branches_with_commits = set()

                for branch in user_branches:
                    try:
                        # Get commits from this branch since yesterday
                        commits = list(repo.iter_commits(branch, since=yesterday.strftime('%Y-%m-%d')))

                        # Filter by user's email
                        for commit in commits:
                            if user_email in commit.author.email:
                                user_commits.append(commit)
                                # Track which branch has commits
                                branches_with_commits.add(branch.replace('origin/', ''))
                    except:
                        pass

                stats['commits'] = len(user_commits)
                stats['branches'] = sorted(list(branches_with_commits))

                # Count lines changed
                for commit in user_commits:
                    try:
                        diff_stats = commit.stats.total
                        stats['lines_added'] += diff_stats.get('insertions', 0)
                        stats['lines_removed'] += diff_stats.get('deletions', 0)
                    except:
                        pass

        except Exception as e:
            stats['git_error'] = str(e)

        # Get GitHub PRs
        try:
            if self.mygithub:
                # Get all open PRs
                all_prs = self.mygithub.get_prs()

                # Extract username from email (everything before @)
                username_hint = user_email.split('@')[0].lower()

                # Filter for user's PRs (by email or username)
                for pr in all_prs:
                    # Check if PR author matches
                    pr_email = pr.get('user', {}).get('email', '').lower()
                    pr_login = pr.get('user', {}).get('login', '').lower()

                    if pr_email == user_email.lower() or username_hint in pr_login:
                        age_days = self.mygithub.get_pr_agedays(pr)
                        stats['prs'].append({
                            'number': pr['number'],
                            'title': pr['title'],
                            'age_days': age_days,
                            'url': pr['html_url']
                        })
        except Exception as e:
            stats['pr_error'] = str(e)

        return stats

    def generate_daily_summary(self, user_info: Dict[str, str], stats: Dict[str, Any]) -> str:
        """Generate a two-sentence AI summary of user's daily activities"""
        user_email = user_info['email']
        user_display = user_info['display']

        try:
            # Authenticate with GitHub Copilot (following interactive_chat.py pattern)
            auth = CopilotAuth()
            cache = AuthCache()

            # Check for cached chat token first
            cached_chat_token = cache.get_valid_cached_chat_token()
            if not cached_chat_token:
                return "Summary unavailable (not authenticated with GitHub Copilot)"

            # Verify token is still valid
            if not auth.verify_chat_token(cached_chat_token):
                cache.clear_chat_token()
                return "Summary unavailable (chat token expired)"

            # Create client and set token
            client = CopilotClient()
            client.set_chat_token(cached_chat_token)

            # Cache in memory for this session
            auth.cache_tokens_in_memory("", cached_chat_token)

            # Create long form report in temp file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                temp_file = f.name

                f.write(f"=== Daily Activity Report for {user_display} ===\n")
                f.write(f"Date: {datetime.datetime.now().strftime('%Y-%m-%d')}\n\n")

                # Write Jira ticket activity
                f.write("## Jira Tickets (Active)\n\n")
                if stats.get('tickets'):
                    for ticket in stats['tickets']:
                        f.write(f"Ticket: {ticket['key']}\n")
                        f.write(f"Status: {ticket['status']}\n")
                        f.write(f"Summary: {ticket['summary']}\n")
                        f.write(f"Last updated: {ticket['days']} days ago\n")

                        # Get comments from last 24 hours
                        try:
                            issue = self.jira.get_issue_by_key(ticket['key'])
                            comments = self.jira.jira.comments(issue)
                            yesterday = datetime.datetime.now() - datetime.timedelta(days=1)

                            recent_comments = []
                            for comment in comments:
                                comment_date = datetime.datetime.strptime(comment.created[:19], '%Y-%m-%dT%H:%M:%S')
                                if comment_date >= yesterday and user_email in comment.author.emailAddress:
                                    recent_comments.append(comment.body)

                            if recent_comments:
                                f.write(f"Recent comments by {user_display}:\n")
                                for comment_body in recent_comments:
                                    f.write(f"  - {comment_body[:200]}\n")
                        except:
                            pass

                        f.write("\n")
                else:
                    f.write("No active tickets\n\n")

                # Write Git commit activity
                f.write("## Git Commits (Yesterday)\n\n")
                f.write(f"Total commits: {stats.get('commits', 0)}\n")
                f.write(f"Lines added: {stats.get('lines_added', 0)}\n")
                f.write(f"Lines removed: {stats.get('lines_removed', 0)}\n")

                if stats.get('branches'):
                    f.write(f"Branches with commits:\n")
                    for branch in stats['branches']:
                        f.write(f"  - {branch}\n")

                        # Get commit messages from this branch
                        try:
                            if os.path.exists(GIT_REPO_PATH):
                                repo = Repo(GIT_REPO_PATH)
                                yesterday = datetime.datetime.now() - datetime.timedelta(days=1)
                                commits = list(repo.iter_commits(f'origin/{branch}', since=yesterday.strftime('%Y-%m-%d'), max_count=10))

                                for commit in commits:
                                    if user_email in commit.author.email:
                                        f.write(f"    Commit: {commit.message.strip()}\n")
                        except:
                            pass
                    f.write("\n")
                else:
                    f.write("No branches committed to\n\n")

                # Write PR activity
                f.write("## Pull Requests\n\n")
                if stats.get('prs'):
                    for pr in stats['prs']:
                        f.write(f"PR #{pr['number']}: {pr['title']}\n")
                        f.write(f"Open for: {pr['age_days']} days\n\n")
                else:
                    f.write("No open pull requests\n\n")

            # Add the report as context
            client.add_context(temp_file)

            # Ask for a summary
            prompt = f"Based on the activity report provided, write exactly two sentences summarizing what {user_display} did yesterday. Focus on the most important work items and commits. Be concise and specific."

            summary = client.ask(prompt, stream=False)

            # Clean up temp file
            try:
                os.unlink(temp_file)
            except:
                pass

            return summary.strip()

        except Exception as e:
            return f"Summary unavailable: {str(e)[:50]}"

    def update_pane(self, pane_index: int, render: bool = True):
        """Update a pane with user stats"""
        pane = self.panes[pane_index]
        user_info = pane.user_info

        # Collect all data first without rendering
        stats = self.get_user_stats(user_info)
        summary = self.generate_daily_summary(user_info, stats)

        # Now build the display all at once
        pane.clear()

        # Display AI summary
        pane.add_line("AI SUMMARY:")
        # Split summary into multiple lines if needed (word wrap)
        summary_words = summary.split()
        current_line = "  "
        for word in summary_words:
            if len(current_line) + len(word) + 1 > 70:  # Wrap at 70 chars
                pane.add_line(current_line)
                current_line = "  " + word
            else:
                current_line += " " + word if current_line != "  " else word
        if current_line.strip():
            pane.add_line(current_line)

        pane.add_line("")

        # Display tickets
        pane.add_line("CURRENT TICKETS:")
        if 'tickets_error' in stats:
            pane.add_line(f"  Error: {stats['tickets_error']}")
        elif stats['tickets']:
            for ticket in stats['tickets']:
                days_text = f"{ticket['days']}d" if ticket['days'] > 0 else "today"
                summary = ticket['summary'][:35] + "..." if len(ticket['summary']) > 35 else ticket['summary']
                pane.add_line(f"  {ticket['key']} [{ticket['status']}] {summary} ({days_text})")
        else:
            pane.add_line("  No tickets assigned")

        pane.add_line("")

        # Display commit stats
        pane.add_line("YESTERDAY'S ACTIVITY:")
        if 'git_error' in stats:
            pane.add_line(f"  Error: {stats['git_error']}")
        else:
            pane.add_line(f"  Commits: {stats['commits']}")
            pane.add_line(f"  Lines added: {stats['lines_added']}")
            pane.add_line(f"  Lines removed: {stats['lines_removed']}")
            net_lines = stats['lines_added'] - stats['lines_removed']
            pane.add_line(f"  Net lines: {net_lines:+d}")

            if stats['branches']:
                pane.add_line(f"  Branches ({len(stats['branches'])}):")
                for branch in stats['branches'][:5]:  # Show first 5
                    pane.add_line(f"    - {branch[:40]}")
                if len(stats['branches']) > 5:
                    pane.add_line(f"    ... and {len(stats['branches']) - 5} more")
            else:
                pane.add_line("  No branches committed to")

        pane.add_line("")

        # Display PRs
        pane.add_line("OPEN PULL REQUESTS:")
        if 'pr_error' in stats:
            pane.add_line(f"  Error: {stats['pr_error']}")
        elif stats['prs']:
            for pr in stats['prs']:
                pane.add_line(f"  #{pr['number']}: {pr['title'][:40]}")
                pane.add_line(f"    Open for: {pr['age_days']} days")
        else:
            pane.add_line("  No open PRs")

        # Only render if requested (to avoid flickering when updating in parallel)
        if render:
            pane.render()

    def update_all_panes(self):
        """Update all panes in parallel using threading"""
        threads = []

        # Create a thread for each pane (don't render yet to avoid flickering)
        for i in range(len(self.panes)):
            thread = threading.Thread(target=self.update_pane, args=(i, False))
            threads.append(thread)
            thread.start()

        # Wait for all threads to complete
        for thread in threads:
            thread.join()

        # Now render all panes at once (thread-safe since we're in main thread)
        for pane in self.panes:
            pane.render()

        # Refresh the main screen to ensure everything is displayed properly
        self.stdscr.refresh()

    def select_pane(self, index: int):
        """Select a pane by index"""
        if 0 <= index < len(self.panes):
            # Deselect old pane
            self.panes[self.selected_pane].is_selected = False
            # Select new pane
            self.selected_pane = index
            self.panes[self.selected_pane].is_selected = True
            # Re-render both panes
            self.render_all_panes()

    def render_all_panes(self):
        """Render all panes"""
        for pane in self.panes:
            pane.render()
        self.stdscr.refresh()

    def copy_to_clipboard(self, text: str) -> bool:
        """Copy text to clipboard using OSC 52 escape sequence (works over SSH!)"""
        try:
            import base64
            import sys

            # Encode text to base64
            b64_text = base64.b64encode(text.encode('utf-8')).decode('ascii')

            # OSC 52 escape sequence: ESC ] 52 ; c ; <base64> BEL
            # This works in Windows Terminal, iTerm2, tmux, and many other terminals
            osc52 = f"\033]52;c;{b64_text}\007"

            # Write directly to the terminal (bypassing curses)
            sys.stdout.write(osc52)
            sys.stdout.flush()

            return True
        except Exception as e:
            return False

    def handle_mouse(self, mouse_event):
        """Handle mouse events including selection"""
        try:
            _, x, y, _, button_state = mouse_event

            # Button 1 pressed (start selection)
            if button_state & curses.BUTTON1_PRESSED:
                # Check which pane was clicked
                for i, pane in enumerate(self.panes):
                    if pane.contains_point(y, x):
                        # Select the pane if not already selected
                        if self.selected_pane != i:
                            self.select_pane(i)
                            # Clear all selections when switching panes
                            for p in self.panes:
                                p.clear_selection()

                        # Clear any existing selections in OTHER panes
                        for j, p in enumerate(self.panes):
                            if j != i:
                                p.clear_selection()

                        # Start selection in this pane
                        pane.start_selection(y, x)
                        # Don't render yet - wait for release to show selection
                        break

            # Button 1 released (end selection at release position)
            elif button_state & curses.BUTTON1_RELEASED:
                for i, pane in enumerate(self.panes):
                    if pane.is_selecting and pane.contains_point(y, x):
                        # Update selection endpoint to release position
                        pane.update_selection(y, x)
                        pane.end_selection()
                        pane.render()
                        self.stdscr.refresh()
                        break

        except:
            pass

    def run(self):
        """Main loop"""
        self.stdscr.clear()
        self.stdscr.refresh()

        # Select first pane by default
        self.panes[self.selected_pane].is_selected = True

        # Status line at bottom
        status_text = "q:quit r:refresh c:copy selection Mouse:drag to select Up/Down:scroll PgUp/PgDn:page Tab:next pane"
        self.stdscr.addstr(curses.LINES - 1, 0, "Loading all reports in parallel..." + " " * (curses.COLS - 35), curses.A_REVERSE)
        self.stdscr.refresh()

        # Initial update (all panes in parallel)
        self.update_all_panes()

        self.stdscr.addstr(curses.LINES - 1, 0, status_text[:curses.COLS - 1], curses.A_REVERSE)
        self.stdscr.refresh()

        # Wait for user input
        while True:
            try:
                key = self.stdscr.getch()
            except KeyboardInterrupt:
                # Ignore Ctrl-C so it doesn't quit - let terminal handle it
                continue

            if key == ord('q') or key == ord('Q'):
                break
            elif key == ord('r') or key == ord('R'):
                # Refresh data (all panes in parallel)
                self.stdscr.addstr(curses.LINES - 1, 0, "Refreshing all reports..." + " " * (curses.COLS - 25), curses.A_REVERSE)
                self.stdscr.refresh()
                self.update_all_panes()
                self.stdscr.addstr(curses.LINES - 1, 0, status_text[:curses.COLS - 1], curses.A_REVERSE)
                self.stdscr.refresh()
            elif key == curses.KEY_MOUSE:
                # Handle mouse click
                try:
                    mouse_event = curses.getmouse()
                    self.handle_mouse(mouse_event)
                except:
                    pass
            elif key == curses.KEY_UP:
                # Scroll up in selected pane
                self.panes[self.selected_pane].scroll_up()
                self.panes[self.selected_pane].render()
            elif key == curses.KEY_DOWN:
                # Scroll down in selected pane
                self.panes[self.selected_pane].scroll_down()
                self.panes[self.selected_pane].render()
            elif key == curses.KEY_PPAGE:  # Page Up
                self.panes[self.selected_pane].page_up()
                self.panes[self.selected_pane].render()
            elif key == curses.KEY_NPAGE:  # Page Down
                self.panes[self.selected_pane].page_down()
                self.panes[self.selected_pane].render()
            elif key == ord('\t') or key == 9:  # Tab key
                # Switch to next pane
                next_pane = (self.selected_pane + 1) % len(self.panes)
                self.select_pane(next_pane)
            elif key == ord('c') or key == ord('C'):  # Copy selection
                # Get selected text from active pane
                pane = self.panes[self.selected_pane]
                selected_text = pane.get_selected_text()
                if selected_text:
                    if self.copy_to_clipboard(selected_text):
                        # Show success message
                        self.stdscr.addstr(curses.LINES - 1, 0, "Copied to clipboard!" + " " * (curses.COLS - 21), curses.A_REVERSE)
                        self.stdscr.refresh()
                        import time
                        time.sleep(1)  # Show for 1 second
                        self.stdscr.addstr(curses.LINES - 1, 0, status_text[:curses.COLS - 1], curses.A_REVERSE)
                        self.stdscr.refresh()
                    else:
                        # Show error message
                        self.stdscr.addstr(curses.LINES - 1, 0, "Copy failed" + " " * (curses.COLS - 12), curses.A_REVERSE)
                        self.stdscr.refresh()
                        import time
                        time.sleep(2)  # Show for 2 seconds
                        self.stdscr.addstr(curses.LINES - 1, 0, status_text[:curses.COLS - 1], curses.A_REVERSE)
                        self.stdscr.refresh()
                else:
                    # No selection
                    self.stdscr.addstr(curses.LINES - 1, 0, "No text selected" + " " * (curses.COLS - 17), curses.A_REVERSE)
                    self.stdscr.refresh()
                    import time
                    time.sleep(1)  # Show for 1 second
                    self.stdscr.addstr(curses.LINES - 1, 0, status_text[:curses.COLS - 1], curses.A_REVERSE)
                    self.stdscr.refresh()
            elif key == 27:  # Escape key - clear selection
                for pane in self.panes:
                    pane.clear_selection()
                    pane.render()


def main(stdscr):
    """Main entry point"""
    try:
        dashboard = Dashboard(stdscr)
        dashboard.run()
    except Exception as e:
        # Make sure we exit curses mode before printing error
        curses.endwin()
        import traceback
        print("Error occurred:")
        print(traceback.format_exc())
        raise


if __name__ == "__main__":
    try:
        curses.wrapper(main)
    except Exception as e:
        # Ensure terminal is restored
        import sys
        print(f"\nFatal error: {e}", file=sys.stderr)
        sys.exit(1)
