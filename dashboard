#!/usr/bin/python3

import curses
import datetime
from typing import Dict, List, Any, Optional
from libs.MyJira import MyJira
from libs.MyGithub import MyGithub
from libs.MyJiraConfig import MyJiraConfig
from git import Repo
import os
import tempfile
import threading
from pycopilot import AuthCache

# Users to track
TRACKED_USERS = [
    {"email": "ncrowley@beyondtrust.com", "display": "Nick Crowley", "initials": "nc"},
    {"email": "nwicker@beyondtrust.com", "display": "Neil Wicker", "initials": "nw"},
    {"email": "tvarady@beyondtrust.com", "display": "Tamas Varady", "initials": "tv"},
    {"email": "jstephenson@beyondtrust.com", "display": "Josh Stephenson", "initials": "js"}
]
GIT_REPO_PATH = os.path.expanduser("~/Code/epm-windows")

class DashboardPane:
    """Represents a single pane in the dashboard"""
    def __init__(self, window, title: str):
        self.window = window
        self.title = title
        self.lines: List[str] = []
        self.scroll_offset = 0
        self.is_selected = False
        self.selection_start = None  # (line, col) tuple
        self.selection_end = None    # (line, col) tuple
        self.is_selecting = False
        self.word_select_mode = False  # True when double-clicked

    def add_line(self, text: str):
        """Add a line of text to the pane"""
        self.lines.append(text)

    def clear(self):
        """Clear all lines"""
        self.lines = []
        self.scroll_offset = 0

    def scroll_up(self):
        """Scroll up by one line"""
        if self.scroll_offset > 0:
            self.scroll_offset -= 1

    def scroll_down(self):
        """Scroll down by one line"""
        h, w = self.window.getmaxyx()
        max_visible = h - 2  # Account for borders
        if self.scroll_offset + max_visible < len(self.lines):
            self.scroll_offset += 1

    def page_up(self):
        """Scroll up by one page"""
        h, w = self.window.getmaxyx()
        page_size = h - 2
        self.scroll_offset = max(0, self.scroll_offset - page_size)

    def page_down(self):
        """Scroll down by one page"""
        h, w = self.window.getmaxyx()
        page_size = h - 2
        max_offset = max(0, len(self.lines) - page_size)
        self.scroll_offset = min(max_offset, self.scroll_offset + page_size)

    def contains_point(self, y: int, x: int) -> bool:
        """Check if a point (y, x) is within this pane"""
        pane_y, pane_x = self.window.getbegyx()
        pane_h, pane_w = self.window.getmaxyx()
        return (pane_y <= y < pane_y + pane_h and
                pane_x <= x < pane_x + pane_w)

    def get_line_col_from_point(self, y: int, x: int) -> Optional[tuple]:
        """Convert screen coordinates to (line, col) within pane content"""
        pane_y, pane_x = self.window.getbegyx()
        pane_h, pane_w = self.window.getmaxyx()

        # Calculate relative position within pane
        rel_y = y - pane_y - 1  # -1 for border
        rel_x = x - pane_x - 1  # -1 for border

        # Check if within content area
        if rel_y < 0 or rel_y >= pane_h - 2 or rel_x < 0 or rel_x >= pane_w - 2:
            return None

        # Calculate actual line number with scroll offset
        line = self.scroll_offset + rel_y

        # Check if line exists
        if line >= len(self.lines):
            return None

        return (line, rel_x)

    def start_selection(self, y: int, x: int):
        """Start text selection at given screen coordinates"""
        pos = self.get_line_col_from_point(y, x)
        if pos:
            self.selection_start = pos
            self.selection_end = pos
            self.is_selecting = True

    def update_selection(self, y: int, x: int):
        """Update selection end point"""
        if self.is_selecting:
            pos = self.get_line_col_from_point(y, x)
            if pos:
                self.selection_end = pos

    def end_selection(self):
        """End selection"""
        self.is_selecting = False

    def clear_selection(self):
        """Clear the current selection"""
        self.selection_start = None
        self.selection_end = None
        self.is_selecting = False
        self.word_select_mode = False

    def find_word_boundaries(self, line: int, col: int) -> tuple:
        """Find the start and end of the word at the given position"""
        if line >= len(self.lines):
            return (col, col)

        text = self.lines[line]
        if col >= len(text):
            return (col, col)

        # Find start of word (go backwards until we hit a non-word character)
        start = col
        while start > 0 and (text[start - 1].isalnum() or text[start - 1] in '_-'):
            start -= 1

        # Find end of word (go forwards until we hit a non-word character)
        end = col
        while end < len(text) and (text[end].isalnum() or text[end] in '_-'):
            end += 1

        return (start, end - 1)

    def start_word_selection(self, y: int, x: int):
        """Start word selection at given screen coordinates"""
        pos = self.get_line_col_from_point(y, x)
        if pos:
            line, col = pos
            start_col, end_col = self.find_word_boundaries(line, col)
            self.selection_start = (line, start_col)
            self.selection_end = (line, end_col)
            self.is_selecting = True
            self.word_select_mode = True

    def update_word_selection(self, y: int, x: int):
        """Update selection to include words from start to current position"""
        if not self.selection_start:
            return

        pos = self.get_line_col_from_point(y, x)
        if pos:
            line, col = pos
            start_line, start_col = self.selection_start

            # Find word boundary at current position
            _, end_col = self.find_word_boundaries(line, col)

            # Update endpoint
            self.selection_end = (line, end_col)

    def get_selected_text(self) -> str:
        """Get the currently selected text"""
        if not self.selection_start or not self.selection_end:
            return ""

        start_line, start_col = self.selection_start
        end_line, end_col = self.selection_end

        # Ensure start is before end
        if start_line > end_line or (start_line == end_line and start_col > end_col):
            start_line, start_col, end_line, end_col = end_line, end_col, start_line, start_col

        selected_text = []

        if start_line == end_line:
            # Single line selection
            line_text = self.lines[start_line]
            selected_text.append(line_text[start_col:end_col + 1])
        else:
            # Multi-line selection
            # First line
            selected_text.append(self.lines[start_line][start_col:])

            # Middle lines
            for line_num in range(start_line + 1, end_line):
                if line_num < len(self.lines):
                    selected_text.append(self.lines[line_num])

            # Last line
            if end_line < len(self.lines):
                selected_text.append(self.lines[end_line][:end_col + 1])

        return '\n'.join(selected_text)

    def render(self):
        """Render the pane content"""
        self.window.clear()
        h, w = self.window.getmaxyx()

        # Draw border (highlighted if selected)
        if self.is_selected:
            self.window.attron(curses.A_BOLD)
            self.window.box()
            self.window.attroff(curses.A_BOLD)
        else:
            self.window.box()

        # Draw title
        title_text = f" {self.title} "
        if self.is_selected:
            title_text += "[ACTIVE] "
        self.window.addstr(0, 2, title_text, curses.A_BOLD)

        # Show scroll indicator if needed
        if len(self.lines) > h - 2:
            scroll_info = f" [{self.scroll_offset + 1}-{min(self.scroll_offset + h - 2, len(self.lines))}/{len(self.lines)}] "
            try:
                self.window.addstr(0, w - len(scroll_info) - 2, scroll_info)
            except:
                pass

        # Draw content with scroll offset and selection highlighting
        y = 1
        for i, line in enumerate(self.lines[self.scroll_offset:]):
            if y >= h - 1:  # Leave space for bottom border
                break

            line_num = self.scroll_offset + i
            display_line = line[:w-3] if len(line) > w-3 else line

            # Check if this line has selection
            if self.selection_start and self.selection_end:
                start_line, start_col = self.selection_start
                end_line, end_col = self.selection_end

                # Normalize selection (ensure start is before end)
                if start_line > end_line or (start_line == end_line and start_col > end_col):
                    start_line, start_col, end_line, end_col = end_line, end_col, start_line, start_col

                # Check if current line is in selection range
                if start_line <= line_num <= end_line:
                    # Determine selection range for this line
                    sel_start = 0
                    sel_end = len(display_line)

                    if line_num == start_line:
                        sel_start = start_col
                    if line_num == end_line:
                        sel_end = min(end_col + 1, len(display_line))

                    # Draw line with selection highlighting
                    try:
                        x_pos = 1
                        # Before selection
                        if sel_start > 0:
                            self.window.addstr(y, x_pos, display_line[:sel_start])
                            x_pos += sel_start

                        # Selection
                        if sel_start < sel_end:
                            selected_part = display_line[sel_start:sel_end]
                            self.window.addstr(y, x_pos, selected_part, curses.A_REVERSE)
                            x_pos += len(selected_part)

                        # After selection
                        if sel_end < len(display_line):
                            self.window.addstr(y, x_pos, display_line[sel_end:])
                    except:
                        pass
                else:
                    # No selection on this line
                    try:
                        self.window.addstr(y, 1, display_line)
                    except:
                        pass
            else:
                # No selection at all
                try:
                    self.window.addstr(y, 1, display_line)
                except:
                    pass

            y += 1

        self.window.refresh()


class Dashboard:
    """Main dashboard class"""
    def __init__(self, stdscr):
        self.stdscr = stdscr
        curses.curs_set(0)  # Hide cursor

        # Initialize colors for diff display
        if curses.has_colors():
            curses.start_color()
            curses.use_default_colors()
            curses.init_pair(1, curses.COLOR_GREEN, -1)  # Added lines
            curses.init_pair(2, curses.COLOR_RED, -1)    # Removed lines
            curses.init_pair(3, curses.COLOR_CYAN, -1)   # Diff headers

        # Enable mouse events - need ALL_MOUSE_EVENTS for drag selection
        curses.mousemask(curses.ALL_MOUSE_EVENTS)

        # Enable mouse motion tracking with escape sequences
        # This tells the terminal to send mouse motion events while button is pressed
        import sys
        sys.stdout.write('\033[?1002h')  # Enable button-event tracking (motion while pressed)
        sys.stdout.flush()

        # Load config and initialize services
        config_file = MyJiraConfig()
        if not config_file.exists():
            raise Exception("Configuration file not found. Run main jira script first.")

        config = config_file.load()
        self.jira = MyJira(config.get('jira'))
        self.mygithub = MyGithub(config.get('github')) if config.get('github')['token'] != "" else None

        # Calculate lookback period (extend on Mondays to include Friday)
        self.lookback_days = self._calculate_lookback_days()
        self.lookback_label = f"Last {self.lookback_days * 24}h" if self.lookback_days > 1 else "Last 24h"

        # Set up panes
        self.panes: List[DashboardPane] = []
        self.selected_pane = 0  # Index of currently selected pane
        self._create_panes()

    def _calculate_lookback_days(self) -> int:
        """Calculate how many days to look back based on current day.
        On Mondays, look back 3 days to include Friday's activity."""
        today = datetime.datetime.now()
        if today.weekday() == 0:  # Monday
            return 3
        return 1

    def _create_panes(self):
        """Create the 4 panes in a 2x2 grid"""
        height, width = self.stdscr.getmaxyx()

        # Calculate pane dimensions
        pane_height = height // 2
        pane_width = width // 2

        # Create windows for each pane, one per user
        positions = [
            (0, 0),  # Top-left
            (0, pane_width),  # Top-right
            (pane_height, 0),  # Bottom-left
            (pane_height, pane_width)  # Bottom-right
        ]

        sizes = [
            (pane_height, pane_width),  # Top-left
            (pane_height, width - pane_width),  # Top-right
            (height - pane_height, pane_width),  # Bottom-left
            (height - pane_height, width - pane_width)  # Bottom-right
        ]

        for i, user_info in enumerate(TRACKED_USERS):
            h, w = sizes[i]
            y, x = positions[i]
            win = curses.newwin(h, w, y, x)
            pane = DashboardPane(win, f"{user_info['display']} - {self.lookback_label}")
            pane.user_info = user_info  # Store user info in pane
            self.panes.append(pane)

    def get_user_stats(self, user_info: Dict[str, str]) -> Dict[str, Any]:
        """Gather statistics about a user from various sources"""
        user_email = user_info['email']
        user_initials = user_info['initials']

        stats = {
            'tickets': [],
            'commits': 0,
            'branches': [],
            'lines_added': 0,
            'lines_removed': 0,
            'prs': []
        }

        # Get Jira tickets assigned to user (excluding Done, Won't Do, New, Approved, and stale items)
        try:
            query = f'assignee = "{user_email}" AND status not in (Done, Closed, New, Approved, "Won\'t Do") AND updated >= -15d ORDER BY updated DESC'
            issues = self.jira.search_issues(query)

            for issue in issues:  # Show all matching tickets
                # Calculate how long since last update
                updated = datetime.datetime.strptime(issue.fields.updated[:19], '%Y-%m-%dT%H:%M:%S')
                days_since_update = (datetime.datetime.now() - updated).days

                # Skip items not modified in more than 15 days (double-check filter)
                if days_since_update > 15:
                    continue

                stats['tickets'].append({
                    'key': issue.key,
                    'summary': issue.fields.summary,
                    'status': str(issue.fields.status),
                    'days': days_since_update,
                    'url': issue.permalink()
                })
        except Exception as e:
            stats['tickets_error'] = str(e)

        # Get Git stats from the lookback period from user's branches on origin
        try:
            if os.path.exists(GIT_REPO_PATH):
                repo = Repo(GIT_REPO_PATH)
                yesterday = datetime.datetime.now() - datetime.timedelta(days=self.lookback_days)

                # Find all origin branches that start with user's initials
                user_branches = []
                try:
                    all_branches = repo.git.branch('-r').split('\n')
                    for branch in all_branches:
                        branch = branch.strip()
                        # Look for origin/{initials}/ branches
                        if branch.startswith(f'origin/{user_initials}/'):
                            user_branches.append(branch)
                except:
                    pass

                # Collect commits from user's branches
                user_commits = []
                branches_with_commits = set()

                for branch in user_branches:
                    try:
                        # Get commits from this branch since yesterday
                        commits = list(repo.iter_commits(branch, since=yesterday.strftime('%Y-%m-%d')))

                        # Filter by user's email
                        for commit in commits:
                            if user_email in commit.author.email:
                                user_commits.append(commit)
                                # Track which branch has commits
                                branches_with_commits.add(branch.replace('origin/', ''))
                    except:
                        pass

                stats['commits'] = len(user_commits)
                stats['branches'] = sorted(list(branches_with_commits))

                # Count lines changed
                for commit in user_commits:
                    try:
                        diff_stats = commit.stats.total
                        stats['lines_added'] += diff_stats.get('insertions', 0)
                        stats['lines_removed'] += diff_stats.get('deletions', 0)
                    except:
                        pass

        except Exception as e:
            stats['git_error'] = str(e)

        # Get GitHub PRs
        try:
            if self.mygithub:
                # Get all open PRs
                all_prs = self.mygithub.get_prs()

                # Extract username from email (everything before @)
                username_hint = user_email.split('@')[0].lower()

                # Filter for user's PRs (by email or username)
                for pr in all_prs:
                    # Check if PR author matches
                    pr_email = pr.get('user', {}).get('email', '').lower()
                    pr_login = pr.get('user', {}).get('login', '').lower()

                    if pr_email == user_email.lower() or username_hint in pr_login:
                        age_days = self.mygithub.get_pr_agedays(pr)
                        stats['prs'].append({
                            'number': pr['number'],
                            'title': pr['title'],
                            'age_days': age_days,
                            'url': pr['html_url']
                        })
        except Exception as e:
            stats['pr_error'] = str(e)

        return stats

    def generate_daily_summary(self, user_info: Dict[str, str], stats: Dict[str, Any]) -> str:
        """Generate a two-sentence AI summary of user's daily activities"""
        user_email = user_info['email']
        user_display = user_info['display']

        try:
            # Authenticate with GitHub Copilot (following bropilot pattern)
            cache = AuthCache()
            client = cache.authenticate()

            if not client:
                return "Summary unavailable (not authenticated with GitHub Copilot)"

            # Create long form report in temp file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                temp_file = f.name

                f.write(f"=== Daily Activity Report for {user_display} ===\n")
                f.write(f"Date: {datetime.datetime.now().strftime('%Y-%m-%d')}\n\n")

                # Write Jira ticket activity
                f.write("## Jira Tickets (Active)\n\n")
                if stats.get('tickets'):
                    for ticket in stats['tickets']:
                        f.write(f"Ticket: {ticket['key']}\n")
                        f.write(f"Status: {ticket['status']}\n")
                        f.write(f"Summary: {ticket['summary']}\n")
                        f.write(f"Last updated: {ticket['days']} days ago\n")

                        # Get comments from lookback period
                        try:
                            issue = self.jira.get_issue_by_key(ticket['key'])
                            comments = self.jira.jira.comments(issue)
                            yesterday = datetime.datetime.now() - datetime.timedelta(days=self.lookback_days)

                            recent_comments = []
                            for comment in comments:
                                comment_date = datetime.datetime.strptime(comment.created[:19], '%Y-%m-%dT%H:%M:%S')
                                if comment_date >= yesterday and user_email in comment.author.emailAddress:
                                    recent_comments.append(comment.body)

                            if recent_comments:
                                f.write(f"Recent comments by {user_display}:\n")
                                for comment_body in recent_comments:
                                    f.write(f"  - {comment_body[:200]}\n")
                        except:
                            pass

                        f.write("\n")
                else:
                    f.write("No active tickets\n\n")

                # Write Git commit activity
                f.write("## Git Commits (Recent Activity)\n\n")
                f.write(f"Total commits: {stats.get('commits', 0)}\n")
                f.write(f"Lines added: {stats.get('lines_added', 0)}\n")
                f.write(f"Lines removed: {stats.get('lines_removed', 0)}\n")

                if stats.get('branches'):
                    f.write(f"Branches with commits:\n")
                    for branch in stats['branches']:
                        f.write(f"  - {branch}\n")

                        # Get commit messages from this branch
                        try:
                            if os.path.exists(GIT_REPO_PATH):
                                repo = Repo(GIT_REPO_PATH)
                                yesterday = datetime.datetime.now() - datetime.timedelta(days=self.lookback_days)
                                commits = list(repo.iter_commits(f'origin/{branch}', since=yesterday.strftime('%Y-%m-%d'), max_count=10))

                                for commit in commits:
                                    if user_email in commit.author.email:
                                        f.write(f"    Commit: {commit.message.strip()}\n")
                        except:
                            pass
                    f.write("\n")
                else:
                    f.write("No branches committed to\n\n")

                # Write PR activity
                f.write("## Pull Requests\n\n")
                if stats.get('prs'):
                    for pr in stats['prs']:
                        f.write(f"PR #{pr['number']}: {pr['title']}\n")
                        f.write(f"Open for: {pr['age_days']} days\n\n")
                else:
                    f.write("No open pull requests\n\n")

            # Add the report as context
            client.add_context(temp_file)

            # Ask for a summary
            time_period = f"over the last {self.lookback_days} days" if self.lookback_days > 1 else "yesterday"
            prompt = f"Based on the activity report provided, write exactly two sentences summarizing what {user_display} did {time_period}. Focus on the most important work items and commits. Be concise and specific."

            summary = client.ask(prompt, stream=False)

            # Clean up temp file
            try:
                os.unlink(temp_file)
            except:
                pass

            return summary.strip()

        except Exception as e:
            return f"Summary unavailable: {str(e)[:50]}"

    def update_pane(self, pane_index: int, render: bool = True):
        """Update a pane with user stats"""
        pane = self.panes[pane_index]
        user_info = pane.user_info

        # Collect all data first without rendering
        stats = self.get_user_stats(user_info)
        summary = self.generate_daily_summary(user_info, stats)

        # Now build the display all at once
        pane.clear()

        # Display AI summary
        pane.add_line("AI SUMMARY:")
        # Split summary into multiple lines if needed (word wrap)
        summary_words = summary.split()
        current_line = "  "
        for word in summary_words:
            if len(current_line) + len(word) + 1 > 70:  # Wrap at 70 chars
                pane.add_line(current_line)
                current_line = "  " + word
            else:
                current_line += " " + word if current_line != "  " else word
        if current_line.strip():
            pane.add_line(current_line)

        pane.add_line("")

        # Display tickets
        pane.add_line("CURRENT TICKETS:")
        if 'tickets_error' in stats:
            pane.add_line(f"  Error: {stats['tickets_error']}")
        elif stats['tickets']:
            for ticket in stats['tickets']:
                days_text = f"{ticket['days']}d" if ticket['days'] > 0 else "today"
                summary = ticket['summary'][:35] + "..." if len(ticket['summary']) > 35 else ticket['summary']
                pane.add_line(f"  {ticket['key']} [{ticket['status']}] {summary} ({days_text})")
        else:
            pane.add_line("  No tickets assigned")

        pane.add_line("")

        # Display commit stats
        activity_label = "RECENT ACTIVITY:" if self.lookback_days > 1 else "YESTERDAY'S ACTIVITY:"
        pane.add_line(activity_label)
        if 'git_error' in stats:
            pane.add_line(f"  Error: {stats['git_error']}")
        else:
            pane.add_line(f"  Commits: {stats['commits']}")
            pane.add_line(f"  Lines added: {stats['lines_added']}")
            pane.add_line(f"  Lines removed: {stats['lines_removed']}")
            net_lines = stats['lines_added'] - stats['lines_removed']
            pane.add_line(f"  Net lines: {net_lines:+d}")

            if stats['branches']:
                pane.add_line(f"  Branches ({len(stats['branches'])}):")
                for branch in stats['branches'][:5]:  # Show first 5
                    pane.add_line(f"    - {branch[:40]}")
                if len(stats['branches']) > 5:
                    pane.add_line(f"    ... and {len(stats['branches']) - 5} more")
            else:
                pane.add_line("  No branches committed to")

        pane.add_line("")

        # Display PRs
        pane.add_line("OPEN PULL REQUESTS:")
        if 'pr_error' in stats:
            pane.add_line(f"  Error: {stats['pr_error']}")
        elif stats['prs']:
            for pr in stats['prs']:
                pane.add_line(f"  #{pr['number']}: {pr['title'][:40]}")
                pane.add_line(f"    Open for: {pr['age_days']} days")
        else:
            pane.add_line("  No open PRs")

        # Only render if requested (to avoid flickering when updating in parallel)
        if render:
            pane.render()

    def update_all_panes(self):
        """Update all panes in parallel using threading"""
        threads = []

        # Create a thread for each pane (don't render yet to avoid flickering)
        for i in range(len(self.panes)):
            thread = threading.Thread(target=self.update_pane, args=(i, False))
            threads.append(thread)
            thread.start()

        # Wait for all threads to complete
        for thread in threads:
            thread.join()

        # Now render all panes at once (thread-safe since we're in main thread)
        for pane in self.panes:
            pane.render()

        # Refresh the main screen to ensure everything is displayed properly
        self.stdscr.refresh()

    def select_pane(self, index: int):
        """Select a pane by index"""
        if 0 <= index < len(self.panes):
            # Deselect old pane
            self.panes[self.selected_pane].is_selected = False
            # Select new pane
            self.selected_pane = index
            self.panes[self.selected_pane].is_selected = True
            # Re-render both panes
            self.render_all_panes()

    def render_all_panes(self):
        """Render all panes"""
        for pane in self.panes:
            pane.render()
        self.stdscr.refresh()

    def copy_to_clipboard(self, text: str) -> bool:
        """Copy text to clipboard using OSC 52 escape sequence (works over SSH!)"""
        try:
            import base64
            import sys

            # Encode text to base64
            b64_text = base64.b64encode(text.encode('utf-8')).decode('ascii')

            # OSC 52 escape sequence: ESC ] 52 ; c ; <base64> BEL
            # This works in Windows Terminal, iTerm2, tmux, and many other terminals
            osc52 = f"\033]52;c;{b64_text}\007"

            # Write directly to the terminal (bypassing curses)
            sys.stdout.write(osc52)
            sys.stdout.flush()

            return True
        except Exception as e:
            return False

    def show_detailed_summary(self):
        """Show detailed AI summary for the currently selected user"""
        pane = self.panes[self.selected_pane]
        user_info = pane.user_info
        user_email = user_info['email']
        user_display = user_info['display']

        # Show loading message
        self.stdscr.addstr(curses.LINES - 1, 0, f"Generating detailed summary for {user_display}..." + " " * 20, curses.A_REVERSE)
        self.stdscr.refresh()

        try:
            # Get user stats
            stats = self.get_user_stats(user_info)

            # Authenticate with GitHub Copilot (following bropilot pattern)
            cache = AuthCache()
            client = cache.authenticate()

            if not client:
                summary = "Summary unavailable (not authenticated with GitHub Copilot)"
                self.show_detail_view(f"Detailed Summary - {user_display}", [summary])
                return

            # Create comprehensive report
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                temp_file = f.name

                f.write(f"=== Detailed Activity Report for {user_display} ===\n")
                f.write(f"Date: {datetime.datetime.now().strftime('%Y-%m-%d')}\n\n")

                # Jira tickets with comments
                f.write("## Jira Tickets and Comments\n\n")
                if stats.get('tickets'):
                    for ticket in stats['tickets']:
                        f.write(f"### {ticket['key']}: {ticket['summary']}\n")
                        f.write(f"Status: {ticket['status']}\n")
                        f.write(f"Last updated: {ticket['days']} days ago\n")
                        f.write(f"URL: {ticket['url']}\n\n")

                        # Get all comments from lookback period
                        try:
                            issue = self.jira.get_issue_by_key(ticket['key'])
                            comments = self.jira.jira.comments(issue)
                            yesterday = datetime.datetime.now() - datetime.timedelta(days=self.lookback_days)

                            recent_comments = []
                            for comment in comments:
                                comment_date = datetime.datetime.strptime(comment.created[:19], '%Y-%m-%dT%H:%M:%S')
                                if comment_date >= yesterday and user_email in comment.author.emailAddress:
                                    recent_comments.append({
                                        'date': comment_date.strftime('%Y-%m-%d %H:%M'),
                                        'body': comment.body
                                    })

                            if recent_comments:
                                f.write(f"Recent comments by {user_display}:\n")
                                for comment_info in recent_comments:
                                    f.write(f"\n[{comment_info['date']}]\n")
                                    f.write(f"{comment_info['body']}\n")
                            else:
                                f.write("No recent comments\n")
                        except:
                            f.write("Could not retrieve comments\n")

                        f.write("\n" + "="*80 + "\n\n")
                else:
                    f.write("No active tickets\n\n")

                # Git commits with detailed info
                f.write("## Git Commits (Recent Activity)\n\n")
                f.write(f"Total commits: {stats.get('commits', 0)}\n")
                f.write(f"Lines added: {stats.get('lines_added', 0)}\n")
                f.write(f"Lines removed: {stats.get('lines_removed', 0)}\n")
                f.write(f"Net lines: {stats.get('lines_added', 0) - stats.get('lines_removed', 0):+d}\n\n")

                if stats.get('branches'):
                    for branch in stats['branches']:
                        f.write(f"### Branch: {branch}\n\n")

                        # Get detailed commit info
                        try:
                            if os.path.exists(GIT_REPO_PATH):
                                repo = Repo(GIT_REPO_PATH)
                                yesterday = datetime.datetime.now() - datetime.timedelta(days=self.lookback_days)
                                commits = list(repo.iter_commits(f'origin/{branch}', since=yesterday.strftime('%Y-%m-%d'), max_count=20))

                                for commit in commits:
                                    if user_email in commit.author.email:
                                        f.write(f"Commit: {commit.hexsha[:8]}\n")
                                        f.write(f"Date: {commit.authored_datetime.strftime('%Y-%m-%d %H:%M:%S')}\n")
                                        f.write(f"Message: {commit.message.strip()}\n")

                                        # Get file changes
                                        try:
                                            diff_stats = commit.stats.files
                                            f.write(f"Files changed ({len(diff_stats)}):\n")
                                            for file_path, stats_dict in list(diff_stats.items())[:10]:  # First 10 files
                                                f.write(f"  {file_path}: +{stats_dict.get('insertions', 0)} -{stats_dict.get('deletions', 0)}\n")
                                            if len(diff_stats) > 10:
                                                f.write(f"  ... and {len(diff_stats) - 10} more files\n")
                                        except:
                                            pass

                                        f.write("\n")
                        except:
                            pass

                        f.write("\n")
                else:
                    f.write("No branches committed to\n\n")

                # Pull requests
                f.write("## Pull Requests\n\n")
                if stats.get('prs'):
                    for pr in stats['prs']:
                        f.write(f"### PR #{pr['number']}: {pr['title']}\n")
                        f.write(f"Open for: {pr['age_days']} days\n")
                        f.write(f"URL: {pr['url']}\n\n")
                else:
                    f.write("No open pull requests\n\n")

            # Add the report as context
            client.add_context(temp_file)

            # Ask for detailed summary
            time_period = f"over the last {self.lookback_days} days" if self.lookback_days > 1 else "over the last 24 hours"
            prompt = f"""Based on the comprehensive activity report provided, write a detailed 4-paragraph summary of {user_display}'s work {time_period}.

Paragraph 1: Overview of main accomplishments and focus areas
Paragraph 2: Detailed analysis of code changes and technical work (commits, files modified, etc.)
Paragraph 3: Jira ticket progress, comments, and communication/collaboration
Paragraph 4: Overall assessment of productivity and any notable patterns or concerns

After the 4 paragraphs, add a section titled "Suggested Standup Questions:" with exactly 2 insightful questions that would be good to ask this person during a daily standup meeting. These questions should be based on their actual work and help uncover blockers, progress, or areas needing clarification.

Be specific and reference actual work items, commit messages, and comments. Write in a professional tone suitable for a daily standup report."""

            summary = client.ask(prompt, stream=False)

            # Clean up temp file
            try:
                os.unlink(temp_file)
            except:
                pass

            # Display the summary
            self.show_detail_view(f"Detailed Summary - {user_display}", [summary.strip()])

        except Exception as e:
            error_msg = f"Error generating summary: {str(e)}"
            self.show_detail_view(f"Detailed Summary - {user_display}", [error_msg])

    def show_commit_details(self):
        """Show detailed commit diffs for the currently selected user"""
        pane = self.panes[self.selected_pane]
        user_info = pane.user_info
        user_email = user_info['email']
        user_initials = user_info['initials']

        # Collect commit diffs
        commit_details = []

        try:
            if os.path.exists(GIT_REPO_PATH):
                repo = Repo(GIT_REPO_PATH)
                yesterday = datetime.datetime.now() - datetime.timedelta(days=self.lookback_days)

                # Find all origin branches that start with user's initials
                user_branches = []
                try:
                    all_branches = repo.git.branch('-r').split('\n')
                    for branch in all_branches:
                        branch = branch.strip()
                        if branch.startswith(f'origin/{user_initials}/'):
                            user_branches.append(branch)
                except:
                    pass

                # Collect commits from user's branches
                for branch in user_branches:
                    try:
                        commits = list(repo.iter_commits(branch, since=yesterday.strftime('%Y-%m-%d')))

                        for commit in commits:
                            if user_email in commit.author.email:
                                # Get the full diff for this commit
                                try:
                                    diff_text = repo.git.show(commit.hexsha, color=False)
                                    commit_details.append(diff_text)
                                except:
                                    pass
                    except:
                        pass
        except Exception as e:
            commit_details.append(f"Error getting commit details: {str(e)}")

        if not commit_details:
            time_period = f"last {self.lookback_days * 24} hours" if self.lookback_days > 1 else "last 24 hours"
            commit_details.append(f"No commits found for {user_info['display']} in the {time_period}")

        # Display in a full-screen view
        self.show_detail_view(f"Commit Details - {user_info['display']}", commit_details)

    def wrap_line(self, line: str, width: int) -> List[str]:
        """Wrap a line to fit within the specified width"""
        if len(line) <= width:
            return [line]

        wrapped_lines = []
        current_line = ""

        # Split into words
        words = line.split(' ')

        for word in words:
            # If adding this word would exceed width
            if current_line and len(current_line) + len(word) + 1 > width:
                wrapped_lines.append(current_line)
                current_line = word
            # If the word itself is longer than width, split it
            elif len(word) > width:
                if current_line:
                    wrapped_lines.append(current_line)
                    current_line = ""
                # Split long word into chunks
                while len(word) > width:
                    wrapped_lines.append(word[:width])
                    word = word[width:]
                current_line = word
            else:
                # Add word to current line
                if current_line:
                    current_line += " " + word
                else:
                    current_line = word

        # Add remaining text
        if current_line:
            wrapped_lines.append(current_line)

        return wrapped_lines if wrapped_lines else [""]

    def show_detail_view(self, title: str, content_blocks: List[str]):
        """Show a full-screen scrollable detail view"""
        scroll_offset = 0

        while True:
            self.stdscr.clear()
            h, w = self.stdscr.getmaxyx()

            # Split content into lines and wrap them
            all_lines = []
            for block in content_blocks:
                for line in block.split('\n'):
                    # Wrap each line to fit the window width
                    wrapped = self.wrap_line(line, w - 2)  # -2 for margins
                    all_lines.extend(wrapped)

            # Draw title
            title_text = f"=== {title} ==="
            try:
                self.stdscr.addstr(0, 0, title_text.center(w)[:w], curses.A_BOLD | curses.A_REVERSE)
            except:
                pass

            # Draw content with scroll
            visible_lines = h - 3  # Leave room for title and status bar
            for i, line in enumerate(all_lines[scroll_offset:scroll_offset + visible_lines]):
                if i + 1 >= h - 1:
                    break
                try:
                    # Color git diff lines
                    if line.startswith('+') and not line.startswith('+++'):
                        self.stdscr.addstr(i + 1, 0, line[:w-1], curses.color_pair(1) if curses.has_colors() else curses.A_NORMAL)
                    elif line.startswith('-') and not line.startswith('---'):
                        self.stdscr.addstr(i + 1, 0, line[:w-1], curses.color_pair(2) if curses.has_colors() else curses.A_NORMAL)
                    elif line.startswith('@@'):
                        self.stdscr.addstr(i + 1, 0, line[:w-1], curses.color_pair(3) if curses.has_colors() else curses.A_BOLD)
                    else:
                        self.stdscr.addstr(i + 1, 0, line[:w-1])
                except:
                    pass

            # Status bar
            max_offset = max(0, len(all_lines) - visible_lines)
            status = f"q/ESC:back Up/Down:scroll PgUp/PgDn:page [{scroll_offset + 1}-{min(scroll_offset + visible_lines, len(all_lines))}/{len(all_lines)}]"
            try:
                self.stdscr.addstr(h - 1, 0, status[:w-1], curses.A_REVERSE)
            except:
                pass

            self.stdscr.refresh()

            # Handle input
            try:
                key = self.stdscr.getch()
            except KeyboardInterrupt:
                continue

            if key == ord('q') or key == ord('Q') or key == 27:  # q or ESC
                break
            elif key == curses.KEY_UP:
                scroll_offset = max(0, scroll_offset - 1)
            elif key == curses.KEY_DOWN:
                scroll_offset = min(max_offset, scroll_offset + 1)
            elif key == curses.KEY_PPAGE:  # Page Up
                scroll_offset = max(0, scroll_offset - visible_lines)
            elif key == curses.KEY_NPAGE:  # Page Down
                scroll_offset = min(max_offset, scroll_offset + visible_lines)

        # Redraw the dashboard
        self.render_all_panes()
        status_text = "q:quit r:refresh s:summary c:commits Drag:select Up/Down:scroll PgUp/PgDn:page Tab:next Esc:clear"
        self.stdscr.addstr(curses.LINES - 1, 0, status_text[:curses.COLS - 1], curses.A_REVERSE)
        self.stdscr.refresh()

    def handle_mouse(self, mouse_event):
        """Handle mouse events including selection"""
        try:
            _, x, y, _, button_state = mouse_event

            # Double-click - select word
            if button_state & curses.BUTTON1_DOUBLE_CLICKED:
                # Check which pane was clicked
                for i, pane in enumerate(self.panes):
                    if pane.contains_point(y, x):
                        # Select the pane if not already selected
                        if self.selected_pane != i:
                            self.select_pane(i)

                        # Clear any existing selections in OTHER panes
                        for j, p in enumerate(self.panes):
                            if j != i:
                                p.clear_selection()

                        # Start word selection
                        pane.start_word_selection(y, x)
                        pane.render()
                        self.stdscr.refresh()
                        break

            # Button 1 pressed (start or continue selection)
            elif button_state & curses.BUTTON1_PRESSED:
                # Check which pane was clicked
                for i, pane in enumerate(self.panes):
                    if pane.contains_point(y, x):
                        # Select the pane if not already selected
                        if self.selected_pane != i:
                            self.select_pane(i)
                            # Clear all selections when switching panes
                            for p in self.panes:
                                p.clear_selection()

                        # If not currently selecting, start new selection
                        if not pane.is_selecting:
                            # Clear any existing selections in OTHER panes
                            for j, p in enumerate(self.panes):
                                if j != i:
                                    p.clear_selection()

                            # Start selection in this pane
                            pane.start_selection(y, x)
                        else:
                            # Already selecting - update endpoint (drag in progress)
                            if pane.word_select_mode:
                                # In word mode, extend by words
                                pane.update_word_selection(y, x)
                            else:
                                # Normal character-by-character selection
                                pane.update_selection(y, x)

                        # Render to show selection as we drag
                        pane.render()
                        self.stdscr.refresh()
                        break

            # Button 1 released (end selection at release position)
            elif button_state & curses.BUTTON1_RELEASED:
                for pane in self.panes:
                    if pane.is_selecting:
                        # Update selection endpoint to release position
                        if pane.word_select_mode:
                            pane.update_word_selection(y, x)
                        else:
                            pane.update_selection(y, x)
                        pane.end_selection()

                        # Automatically copy the selection
                        selected_text = pane.get_selected_text()
                        if selected_text:
                            self.copy_to_clipboard(selected_text)

                        pane.render()
                        self.stdscr.refresh()
                        break

        except:
            pass

    def run(self):
        """Main loop"""
        self.stdscr.clear()
        self.stdscr.refresh()

        # Select first pane by default
        self.panes[self.selected_pane].is_selected = True

        # Status line at bottom
        status_text = "q:quit r:refresh s:summary c:commits Drag:select Up/Down:scroll PgUp/PgDn:page Tab:next Esc:clear"
        self.stdscr.addstr(curses.LINES - 1, 0, "Loading all reports in parallel..." + " " * (curses.COLS - 35), curses.A_REVERSE)
        self.stdscr.refresh()

        # Initial update (all panes in parallel)
        self.update_all_panes()

        self.stdscr.addstr(curses.LINES - 1, 0, status_text[:curses.COLS - 1], curses.A_REVERSE)
        self.stdscr.refresh()

        # Wait for user input
        while True:
            try:
                key = self.stdscr.getch()
            except KeyboardInterrupt:
                # Ignore Ctrl-C so it doesn't quit - let terminal handle it
                continue

            if key == ord('q') or key == ord('Q'):
                break
            elif key == ord('r') or key == ord('R'):
                # Refresh data (all panes in parallel)
                self.stdscr.addstr(curses.LINES - 1, 0, "Refreshing all reports..." + " " * (curses.COLS - 25), curses.A_REVERSE)
                self.stdscr.refresh()
                self.update_all_panes()
                self.stdscr.addstr(curses.LINES - 1, 0, status_text[:curses.COLS - 1], curses.A_REVERSE)
                self.stdscr.refresh()
            elif key == curses.KEY_MOUSE:
                # Handle mouse click
                try:
                    mouse_event = curses.getmouse()
                    self.handle_mouse(mouse_event)
                except:
                    pass
            elif key == curses.KEY_UP:
                # Scroll up in selected pane
                self.panes[self.selected_pane].scroll_up()
                self.panes[self.selected_pane].render()
            elif key == curses.KEY_DOWN:
                # Scroll down in selected pane
                self.panes[self.selected_pane].scroll_down()
                self.panes[self.selected_pane].render()
            elif key == curses.KEY_PPAGE:  # Page Up
                self.panes[self.selected_pane].page_up()
                self.panes[self.selected_pane].render()
            elif key == curses.KEY_NPAGE:  # Page Down
                self.panes[self.selected_pane].page_down()
                self.panes[self.selected_pane].render()
            elif key == ord('\t') or key == 9:  # Tab key
                # Switch to next pane
                next_pane = (self.selected_pane + 1) % len(self.panes)
                self.select_pane(next_pane)
            elif key == ord('s') or key == ord('S'):  # Show detailed summary
                self.show_detailed_summary()
            elif key == ord('c') or key == ord('C'):  # Show commit details
                self.show_commit_details()
            elif key == 27:  # Escape key - clear selection
                for pane in self.panes:
                    pane.clear_selection()
                    pane.render()


def main(stdscr):
    """Main entry point"""
    import sys
    try:
        dashboard = Dashboard(stdscr)
        dashboard.run()
    except Exception as e:
        # Make sure we exit curses mode before printing error
        curses.endwin()
        import traceback
        print("Error occurred:")
        print(traceback.format_exc())
        raise
    finally:
        # Disable mouse motion tracking on exit
        sys.stdout.write('\033[?1002l')
        sys.stdout.flush()


if __name__ == "__main__":
    try:
        curses.wrapper(main)
    except Exception as e:
        # Ensure terminal is restored
        import sys
        print(f"\nFatal error: {e}", file=sys.stderr)
        sys.exit(1)
