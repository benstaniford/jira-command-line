#!/usr/bin/env python3
"""
Regression Report Summarizer and Confluence Uploader

Takes a regression run folder (e.g., ~/testruns/32761) and:
1. Finds all analysis_*.md files in test failure subdirectories
2. Uses copilot to generate one-paragraph summaries
3. Creates a comprehensive summary report
4. Uploads the summary to Confluence
5. Uploads each detailed report as a subpage
"""

import argparse
import json
import os
import re
import sys
import time
from pathlib import Path
from typing import List, Dict, Optional, Tuple

import requests
from requests.auth import HTTPBasicAuth

# Pycopilot imports
from pycopilot import CopilotClient, CopilotAuth, AuthCache, AuthenticationError, APIError

# Local imports
from libs.MyJiraConfig import MyJiraConfig


class RegressionReportSummarizer:
    """Handles summarization and upload of regression test reports."""

    def __init__(self, testruns_dir: str):
        """Initialize with the testruns directory (e.g., ~/testruns/32761)."""
        self.testruns_dir = Path(testruns_dir).expanduser().resolve()

        if not self.testruns_dir.exists():
            raise ValueError(f"Directory does not exist: {self.testruns_dir}")

        # Extract build ID from directory name
        self.build_id = self.testruns_dir.name

        # Initialize Confluence connection
        self._init_confluence()

        # Confluence configuration
        self.space_key = "PMFW"
        self.parent_page_id = "2572025869"  # Regression Reports page

        # Initialize Copilot client for summary generation
        self.copilot_client = self._init_copilot()

    def _init_confluence(self):
        """Initialize Confluence connection using config."""
        config_manager = MyJiraConfig()
        if not config_manager.exists():
            raise ValueError("Config file not found. Please run the main jira application first to generate configuration.")

        config = config_manager.load()
        jira_config = config["jira"]

        # Store connection details
        self.confluence_url = jira_config["url"]
        self.confluence_username = jira_config["username"]
        self.confluence_password = jira_config["password"]

        # Create session for requests
        self.session = requests.Session()
        self.session.auth = HTTPBasicAuth(self.confluence_username, self.confluence_password)
        self.session.headers.update({
            "Content-Type": "application/json",
            "Accept": "application/json"
        })

        print(f"Initialized Confluence connection for {self.confluence_url}")

    def _init_copilot(self) -> Optional[CopilotClient]:
        """Initialize Copilot client for generating summaries."""
        print("Initializing GitHub Copilot for summary generation...")

        try:
            auth = CopilotAuth()
            cache = AuthCache()

            # Try to get valid cached chat token
            cached_chat_token = cache.get_valid_cached_chat_token()
            if cached_chat_token:
                print("âœ“ Using cached Copilot authentication")
                if auth.verify_chat_token(cached_chat_token):
                    client = CopilotClient()
                    client.set_chat_token(cached_chat_token)
                    return client
                else:
                    print("âš  Cached chat token is no longer valid")
                    cache.clear_chat_token()

            # Try to get new chat token from cached bearer token
            cached_bearer_token = cache.get_cached_bearer_token()
            if cached_bearer_token:
                try:
                    print("Getting new chat token from cached bearer token...")
                    chat_token = auth.get_chat_token_from_bearer(cached_bearer_token)
                    cache.cache_chat_token(chat_token)

                    client = CopilotClient()
                    client.set_chat_token(chat_token)
                    print("âœ“ Got new chat token from cached bearer token")
                    return client

                except AuthenticationError:
                    print("âš  Cached bearer token is no longer valid")
                    cache.clear_bearer_token()

            # Need to authenticate via device flow
            print("\nCopilot authentication required...")
            device_response = auth._get_device_code()

            print(f"\nðŸ”— To authenticate with GitHub Copilot:")
            print(f"1. Visit: {device_response['verification_uri']}")
            print(f"2. Enter code: {device_response['user_code']}")
            print(f"3. Complete authentication in your browser")
            print(f"\nWaiting for authentication...", end="", flush=True)

            # Poll for access token
            for attempt in range(120):  # 10 minutes
                try:
                    bearer_token = auth._check_access_token_once(device_response['device_code'])
                    print(f"\nâœ“ Authentication successful!")

                    # Get chat token and cache both tokens
                    chat_token = auth.get_chat_token_from_bearer(bearer_token)
                    cache.cache_bearer_token(bearer_token)
                    cache.cache_chat_token(chat_token)

                    client = CopilotClient()
                    client.set_chat_token(chat_token)
                    print("âœ“ Tokens cached for future use")
                    return client

                except AuthenticationError as e:
                    if "authorization_pending" in str(e) or "slow_down" in str(e):
                        print(".", end="", flush=True)
                        time.sleep(5)
                        continue
                    else:
                        raise e

            print(f"\nâœ— Authentication timeout")
            return None

        except Exception as e:
            print(f"âœ— Failed to initialize Copilot: {e}")
            return None

    def find_analysis_reports(self) -> List[Tuple[Path, str]]:
        """
        Find all analysis_*.md files in the testruns directory.
        Returns list of tuples: (file_path, test_name)

        Analysis files are named like: analysis_TestName_MachineName.md
        """
        reports = []

        # Search for analysis_*.md files at the build level
        for analysis_file in self.testruns_dir.glob('analysis_*.md'):
            # Extract test name from filename
            # Pattern: analysis_TestName_MachineName.md -> TestName_MachineName
            filename = analysis_file.stem  # Gets filename without .md extension

            # Remove "analysis_" prefix
            if filename.startswith('analysis_'):
                test_name = filename[9:]  # len('analysis_') = 9
            else:
                test_name = filename

            reports.append((analysis_file, test_name))
            print(f"Found report: {analysis_file.name} for test {test_name}")

        return sorted(reports)

    def extract_build_info(self, report_path: Path) -> Dict[str, Optional[str]]:
        """
        Extract build version and test date from an analysis report.
        Returns dict with 'build_version' and 'test_date' keys.
        """
        build_version = None
        test_date = None

        try:
            with open(report_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # Extract build version: **Build Version:** 25.9.67.0
            version_match = re.search(r'\*\*Build Version:\*\*\s*([\d.]+)', content)
            if version_match:
                build_version = version_match.group(1)

            # Extract test date: **Test Started:** 2025-10-09 04:18:56
            date_match = re.search(r'\*\*Test Started:\*\*\s*([\d-]+)\s+[\d:]+', content)
            if date_match:
                test_date = date_match.group(1)

        except Exception as e:
            print(f"Warning: Failed to extract build info from {report_path.name}: {e}")

        return {
            'build_version': build_version,
            'test_date': test_date
        }

    def generate_summary(self, report_path: Path) -> str:
        """
        Use Copilot to generate a one-paragraph summary of a report.
        Returns the summary text.
        """
        print(f"\nGenerating summary for: {report_path.name}")

        if not self.copilot_client:
            print("âœ— Copilot client not initialized")
            return "Copilot not available - authentication may have failed."

        try:
            # Add the report as context
            if not self.copilot_client.add_context(str(report_path)):
                print(f"âœ— Failed to add report as context")
                return "Failed to add report to context."

            # Ask for a summary
            prompt = (
                "Please provide a one-paragraph executive summary of this test failure analysis focusing on the cause of the issue. "
                "Include: what failed, root cause if identified, and any proposed fix. "
                "Keep it concise (3-5 sentences max). "
                "Respond with ONLY the summary paragraph, no extra commentary."
            )

            # Get the summary from Copilot
            summary = self.copilot_client.ask(prompt, stream=False)

            # Remove the context file after use
            self.copilot_client.remove_context(str(report_path))

            if summary and summary.strip():
                summary = summary.strip()
                print(f"âœ“ Generated summary ({len(summary)} chars)")
                return summary
            else:
                print(f"âœ— Copilot returned empty response")
                return "Summary generation returned no output."

        except AuthenticationError as e:
            print(f"âœ— Authentication error: {e}")
            return "Authentication error during summary generation."
        except APIError as e:
            print(f"âœ— API error: {e}")
            return f"API error: {str(e)}"
        except Exception as e:
            print(f"âœ— Exception generating summary: {e}")
            return f"Error: {str(e)}"

    def create_summary_report(self, reports: List[Tuple[Path, str]], summaries: Dict[str, str]) -> Path:
        """
        Create a comprehensive summary markdown file.
        Returns the path to the created file.
        """
        summary_file = self.testruns_dir.parent / f"{self.build_id}_summary.md"

        print(f"\nCreating summary report: {summary_file}")

        # Extract build info from first report
        build_info = {'build_version': 'Unknown', 'test_date': 'Unknown'}
        if reports:
            extracted_info = self.extract_build_info(reports[0][0])
            if extracted_info['build_version']:
                build_info['build_version'] = extracted_info['build_version']
            if extracted_info['test_date']:
                build_info['test_date'] = extracted_info['test_date']

        total_failures = len(reports)

        # Azure DevOps build link
        azdo_link = f"https://avecto-vsts.visualstudio.com/Windows/_build/results?buildId={self.build_id}"

        content = f"""# Regression Summary - Build {build_info['build_version']}
**Azure DevOps Regression Run:** [{self.build_id}]({azdo_link})
**EPM Build Version:** {build_info['build_version']}
**Test Date:** {build_info['test_date']}
**Regression Run ID:** {self.build_id}
**Total Failures:** {total_failures}
**Report Generated:** {self._get_timestamp()}
---
## Test Failure Summaries
"""
        # Add each test summary
        for report_path, test_name in reports:
            summary = summaries.get(str(report_path), "No summary available.")
            content += f"""### {test_name}
{summary}
---
"""
        # Add footer
        content += f"""
*Report automatically generated on {self._get_timestamp()}*
"""

        # Write the file
        with open(summary_file, 'w', encoding='utf-8') as f:
            f.write(content)

        print(f"âœ“ Summary report created: {summary_file}")
        return summary_file

    def _get_timestamp(self) -> str:
        """Get current timestamp as formatted string."""
        from datetime import datetime
        return datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    def markdown_to_confluence_storage(self, markdown_content: str) -> str:
        """
        Convert markdown to Confluence storage format (HTML).
        This is a basic conversion - you may want to enhance it.
        """
        # Basic markdown to HTML conversions
        html = markdown_content

        # Headers
        html = re.sub(r'^# (.+)$', r'<h1>\1</h1>', html, flags=re.MULTILINE)
        html = re.sub(r'^## (.+)$', r'<h2>\1</h2>', html, flags=re.MULTILINE)
        html = re.sub(r'^### (.+)$', r'<h3>\1</h3>', html, flags=re.MULTILINE)
        html = re.sub(r'^#### (.+)$', r'<h4>\1</h4>', html, flags=re.MULTILINE)

        # Links (before bold/italic to avoid conflicts)
        html = re.sub(r'\[(.+?)\]\((.+?)\)', r'<a href="\2">\1</a>', html)

        # Bold and italic
        html = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', html)
        html = re.sub(r'\*(.+?)\*', r'<em>\1</em>', html)

        # Code blocks
        html = re.sub(r'```(.+?)```', r'<pre><code>\1</code></pre>', html, flags=re.DOTALL)
        html = re.sub(r'`(.+?)`', r'<code>\1</code>', html)

        # Horizontal rules
        html = re.sub(r'^---$', r'<hr/>', html, flags=re.MULTILINE)

        # Line breaks
        html = html.replace('\n\n', '<br/><br/>')

        return html

    def _create_confluence_page(self, space_key: str, title: str, body: str, parent_id: Optional[str] = None) -> Dict:
        """
        Create a new Confluence page using REST API.
        Returns the created page data.
        """
        url = f"{self.confluence_url}/wiki/rest/api/content"

        payload = {
            "type": "page",
            "title": title,
            "space": {
                "key": space_key
            },
            "body": {
                "storage": {
                    "value": body,
                    "representation": "storage"
                }
            }
        }

        if parent_id:
            payload["ancestors"] = [{"id": parent_id}]

        response = self.session.post(url, json=payload, timeout=30)
        response.raise_for_status()

        return response.json()

    def _get_confluence_page(self, page_id: str) -> Dict:
        """
        Get a Confluence page by ID using REST API.
        Returns the page data.
        """
        url = f"{self.confluence_url}/wiki/rest/api/content/{page_id}"
        params = {
            "expand": "body.storage,version"
        }

        response = self.session.get(url, params=params, timeout=30)
        response.raise_for_status()

        return response.json()

    def _update_confluence_page(self, page_id: str, title: str, body: str, version_number: int) -> Dict:
        """
        Update an existing Confluence page using REST API.
        Returns the updated page data.
        """
        url = f"{self.confluence_url}/wiki/rest/api/content/{page_id}"

        payload = {
            "version": {
                "number": version_number + 1
            },
            "title": title,
            "type": "page",
            "body": {
                "storage": {
                    "value": body,
                    "representation": "storage"
                }
            }
        }

        response = self.session.put(url, json=payload, timeout=30)
        response.raise_for_status()

        return response.json()

    def upload_to_confluence(self, summary_file: Path, reports: List[Tuple[Path, str]]) -> str:
        """
        Upload the summary report and detailed reports to Confluence.
        Returns the URL of the main summary page.
        """
        print(f"\n{'='*80}")
        print("Uploading to Confluence...")
        print(f"{'='*80}\n")

        # Extract build info from first report for the title
        build_info = {'build_version': None, 'test_date': None}
        if reports:
            build_info = self.extract_build_info(reports[0][0])
            print(f"Extracted build info: Version={build_info['build_version']}, Date={build_info['test_date']}")

        # Read summary content
        with open(summary_file, 'r', encoding='utf-8') as f:
            summary_content = f.read()

        # Create main summary page title with date and build version
        if build_info['test_date'] and build_info['build_version']:
            main_title = f"Regression Failures - {build_info['test_date']} - Build {build_info['build_version']}"
        elif build_info['build_version']:
            main_title = f"Regression Failures - Build {build_info['build_version']}"
        else:
            main_title = f"Build {self.build_id} Regression Failures"

        print(f"Creating main page: {main_title}")

        try:
            # Convert markdown to Confluence storage format
            main_content_html = self.markdown_to_confluence_storage(summary_content)

            # Create main page
            main_page = self._create_confluence_page(
                space_key=self.space_key,
                title=main_title,
                body=main_content_html,
                parent_id=self.parent_page_id
            )

            main_page_id = main_page.get("id")
            main_page_url = f"{self.confluence_url}/wiki/spaces/{self.space_key}/pages/{main_page_id}"

            print(f"âœ“ Created main page: {main_page_url}")

            # Upload detailed reports as child pages
            child_page_links = []

            for report_path, test_name in reports:
                print(f"\nUploading detailed report for: {test_name}")

                try:
                    # Read detailed report
                    with open(report_path, 'r', encoding='utf-8') as f:
                        detailed_content = f.read()

                    # Convert to Confluence format
                    detailed_html = self.markdown_to_confluence_storage(detailed_content)

                    # Create child page
                    child_page = self._create_confluence_page(
                        space_key=self.space_key,
                        title=f"{test_name}",
                        body=detailed_html,
                        parent_id=main_page_id
                    )

                    child_page_id = child_page.get("id")
                    child_page_url = f"{self.confluence_url}/wiki/spaces/{self.space_key}/pages/{child_page_id}"

                    child_page_links.append((test_name, child_page_url, child_page_id))
                    print(f"âœ“ Created child page: {child_page_url}")

                except Exception as e:
                    print(f"âœ— Failed to upload detailed report for {test_name}: {e}")
                    continue

            # Update main page with links to child pages
            if child_page_links:
                print(f"\nUpdating main page with links to {len(child_page_links)} detailed reports...")

                # Build links section
                links_html = "<h2>Detailed Test Reports</h2><ul>"
                for test_name, url, page_id in child_page_links:
                    # Use Confluence's internal link format
                    links_html += f'<li><ac:link><ri:page ri:content-title="{test_name}" /></ac:link></li>'
                links_html += "</ul>"

                # Append links to main page
                try:
                    # Get current page version
                    current_page = self._get_confluence_page(main_page_id)
                    current_version = current_page.get("version", {}).get("number", 1)

                    # Update the page
                    updated_main_page = self._update_confluence_page(
                        page_id=main_page_id,
                        title=main_title,
                        body=main_content_html + "<br/><br/>" + links_html,
                        version_number=current_version
                    )
                    print(f"âœ“ Updated main page with child page links")
                except Exception as e:
                    print(f"âœ— Failed to update main page with links: {e}")

            print(f"\n{'='*80}")
            print(f"âœ“ Upload complete!")
            print(f"Main page: {main_page_url}")
            print(f"{'='*80}\n")

            return main_page_url

        except Exception as e:
            print(f"\nâœ— Failed to upload to Confluence: {e}")
            import traceback
            traceback.print_exc()
            return ""

    def run(self, skip_copilot: bool = False, skip_confluence: bool = False):
        """
        Main execution flow.
        """
        print(f"\n{'='*80}")
        print(f"Regression Report Summarizer")
        print(f"{'='*80}\n")
        print(f"Build ID: {self.build_id}")
        print(f"Directory: {self.testruns_dir}")
        print(f"\n{'='*80}\n")

        # Step 1: Find all analysis reports
        print("Step 1: Finding analysis reports...")
        reports = self.find_analysis_reports()

        if not reports:
            print("\nâœ— No analysis reports found!")
            print("Expected to find analysis_*.md files in test failure subdirectories.")
            return

        print(f"\nâœ“ Found {len(reports)} analysis report(s)")

        # Step 2: Generate summaries using copilot
        summaries = {}

        if not skip_copilot:
            print(f"\n{'='*80}")
            print("Step 2: Generating summaries with copilot...")
            print(f"{'='*80}")

            for report_path, test_name in reports:
                summary = self.generate_summary(report_path)
                summaries[str(report_path)] = summary
        else:
            print("\n(Skipping copilot summary generation)")
            for report_path, test_name in reports:
                summaries[str(report_path)] = "Summary generation skipped."

        # Step 3: Create comprehensive summary report
        print(f"\n{'='*80}")
        print("Step 3: Creating summary report...")
        print(f"{'='*80}")

        summary_file = self.create_summary_report(reports, summaries)

        # Step 4: Upload to Confluence
        if not skip_confluence:
            confluence_url = self.upload_to_confluence(summary_file, reports)

            if confluence_url:
                print(f"\n{'='*80}")
                print("âœ“ All done!")
                print(f"Summary file: {summary_file}")
                print(f"Confluence: {confluence_url}")
                print(f"{'='*80}\n")
        else:
            print("\n(Skipping Confluence upload)")
            print(f"\nâœ“ Summary file created: {summary_file}")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Summarize regression test reports and upload to Confluence",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s ~/testruns/32761
  %(prog)s ~/testruns/32761 --skip-copilot
  %(prog)s ~/testruns/32761 --skip-confluence
        """
    )

    parser.add_argument(
        'testruns_dir',
        help='Path to testruns directory (e.g., ~/testruns/32761)'
    )

    parser.add_argument(
        '--skip-copilot',
        action='store_true',
        help='Skip copilot summary generation'
    )

    parser.add_argument(
        '--skip-confluence',
        action='store_true',
        help='Skip Confluence upload (only create local summary)'
    )

    args = parser.parse_args()

    try:
        summarizer = RegressionReportSummarizer(args.testruns_dir)
        summarizer.run(
            skip_copilot=args.skip_copilot,
            skip_confluence=args.skip_confluence
        )
    except KeyboardInterrupt:
        print("\n\nâœ— Cancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"\nâœ— Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
