#!/usr/bin/env python3
"""
Azure DevOps RunRegression Pipeline Viewer
Shows pipeline runs and their failed tests using curses UI.
"""

import curses
import os
import sys
import requests
from requests.auth import HTTPBasicAuth
from base64 import b64encode
from typing import List, Dict, Any, Optional
from datetime import datetime


class AzDoConnection:
    """Handles Azure DevOps API connection and requests."""

    def __init__(self):
        """Initialize connection using environment variables."""
        self.pat_token = os.getenv("AZURE_DEVOPS_EXT_PAT")
        self.org_url = os.getenv("AZ_ORG")
        self.project = os.getenv("AZ_PROJECT")

        if not all([self.pat_token, self.org_url, self.project]):
            raise ValueError(
                "Missing required environment variables: "
                "AZURE_DEVOPS_EXT_PAT, AZ_ORG, AZ_PROJECT"
            )

        # Create authenticated session
        self.session = requests.Session()
        self.session.auth = HTTPBasicAuth("", self.pat_token)
        self.session.headers.update({
            "Content-Type": "application/json",
            "Accept": "application/json"
        })

    def make_request(self, url: str) -> Dict[str, Any]:
        """Make an authenticated GET request to Azure DevOps API."""
        response = self.session.get(url, timeout=120)
        response.raise_for_status()
        return response.json()

    def find_pipeline_by_name(self, name: str) -> Optional[int]:
        """Find a pipeline ID by name."""
        url = f"{self.org_url}/{self.project}/_apis/build/definitions?api-version=6.0"
        data = self.make_request(url)

        for pipeline in data.get("value", []):
            if pipeline["name"] == name:
                return pipeline["id"]

        return None

    def get_pipeline_runs(self, pipeline_id: int, top: int = 50) -> List[Dict[str, Any]]:
        """Get recent runs for a pipeline."""
        url = (
            f"{self.org_url}/{self.project}/_apis/build/builds?"
            f"definitions={pipeline_id}&$top={top}&api-version=6.0"
        )
        data = self.make_request(url)
        return data.get("value", [])

    def get_failed_tests(self, build_id: int) -> List[Dict[str, Any]]:
        """Get failed tests for a build, similar to get_portal_failures.py."""
        # Default filters for specific test suites
        default_filters = [
            'WindowsDriver',
            'AntiTamper',
            'AgentProtection',
            'AppControl',
            'AppMatching',
            'AppMatchingUninstallers',
            'AppPrivMan',
            'BeyondInsightIntegration',
            'Compatibility',
            'ContentControl',
            'ContentMatching',
            'ContentPrivMan',
            'DLLControl',
            'EndpointApp',
            'EventAuditJson',
            'EventAuditLegacy',
            'EventAuditWindowsEvents',
            'FileInformationCaching',
            'Filters',
            'Identity',
            'JITAdmin',
            'JITApplicationAccess',
            'Licensing',
            'Messaging',
            'OnDemand',
            'PasswordSafe',
            'Personas',
            'PowerRules',
            'RegistryKeys',
            'TAP',
            'UAC',
            'Upgrading',
            'Utilities'
        ]

        # Get test runs for the build
        runs_url = (
            f"{self.org_url}/{self.project}/_apis/test/runs?"
            f"buildIds={build_id}&api-version=7.0"
        )

        runs_data = self.make_request(runs_url)

        if not runs_data.get('value'):
            return []

        # Filter to only completed runs
        completed_runs = [
            r for r in runs_data['value']
            if r.get('state') == 'Completed'
        ]

        # Group by run name and get the one with highest ID (most recent)
        latest_runs = {}
        for run in completed_runs:
            run_name = run.get('name', 'Unknown')
            run_id = run['id']

            # Apply default filters - only include specified test suites
            if not any(f in run_name for f in default_filters):
                continue

            # Keep the run with the highest ID for each name
            if run_name not in latest_runs or run_id > latest_runs[run_name]['id']:
                latest_runs[run_name] = run

        # Get failures from each run
        all_failures = []

        for run_name in sorted(latest_runs.keys()):
            run = latest_runs[run_name]
            run_id = run['id']

            # Get failed test results for this run
            results_url = (
                f"{self.org_url}/{self.project}/_apis/test/Runs/{run_id}/results?"
                f"outcomes=Failed&$top=1000&api-version=7.0"
            )

            try:
                results_data = self.make_request(results_url)
            except requests.exceptions.Timeout:
                continue

            # Count actual failures
            for result in results_data.get('value', []):
                outcome = result.get('outcome', '')

                # Only include tests with outcome exactly "Failed"
                if outcome != 'Failed':
                    continue

                test_name = result.get(
                    'testCaseTitle',
                    result.get('automatedTestName', 'Unknown')
                )
                error_message = result.get('errorMessage', '')

                all_failures.append({
                    'run': run_name,
                    'test': test_name,
                    'run_id': run_id,
                    'result_id': result['id'],
                    'error': error_message
                })

        return all_failures

    def get_build_timeline(self, build_id: int) -> Dict[str, Any]:
        """Get the build timeline to find job IDs."""
        url = (
            f"{self.org_url}/{self.project}/_apis/build/builds/{build_id}/"
            f"timeline?api-version=6.0"
        )
        return self.make_request(url)

    def find_copy_task_ids(self, build_id: int) -> List[tuple]:
        """Find all 'Copy test results locally' task IDs and their log IDs."""
        timeline = self.get_build_timeline(build_id)

        copy_tasks = []
        for record in timeline.get('records', []):
            if record.get('type') == 'Task':
                task_name = record.get('name', '')
                if 'Copy test results locally' in task_name:
                    log_ref = record.get('log', {})
                    log_id = log_ref.get('id')
                    if log_id:
                        copy_tasks.append((record.get('id'), log_id))

        return copy_tasks

    def get_build_logs(self, build_id: int, log_id: int) -> List[str]:
        """Download and return the log lines from a build log."""
        url = (
            f"{self.org_url}/{self.project}/_apis/build/builds/{build_id}/"
            f"logs/{log_id}?api-version=6.0"
        )
        response = self.session.get(url, timeout=120)
        response.raise_for_status()
        log_data = response.json()
        return log_data.get('value', [])

    def parse_copy_job_logs(self, build_id: int) -> Dict[str, str]:
        """
        Parse 'Copy test results locally' task logs to extract UNC paths.
        Returns a dict mapping test suite names to their UNC paths.
        """
        import re

        # Find all Copy tasks
        copy_tasks = self.find_copy_task_ids(build_id)
        if not copy_tasks:
            return {}

        # Parse logs for UNC paths
        # Pattern: Copying \\fs01.btrusteng.com\ExecutionProduction\PMfW Regression - <TestSuite>\<GUID>\Endpoints
        # Note: In the JSON log, backslashes appear as single \ not \\
        pattern = r'Copying \\\\fs01\.btrusteng\.com\\ExecutionProduction\\PMfW Regression - ([^\\]+)\\([a-f0-9-]{36})\\Endpoints'

        test_suite_paths = {}

        # Parse logs from all copy tasks
        for task_id, log_id in copy_tasks:
            try:
                log_lines = self.get_build_logs(build_id, log_id)

                # Search through all log lines
                for line in log_lines:
                    match = re.search(pattern, line)
                    if match:
                        test_suite = match.group(1)
                        guid = match.group(2)
                        unc_path = f"\\\\fs01.btrusteng.com\\ExecutionProduction\\PMfW Regression - {test_suite}\\{guid}\\Endpoints"
                        test_suite_paths[test_suite] = unc_path
                        # Found the path for this task, move to next task
                        break

            except Exception:
                # Skip tasks that fail to download
                continue

        return test_suite_paths

    def copy_unc_artifacts(self, unc_path: str, output_dir: str) -> List[str]:
        """
        Recursively scan UNC path for .zip and .dmp files and copy them to output_dir.
        Preserves relative directory structure from the endpoint folder.
        Returns list of copied filenames.
        """
        import os
        import shutil
        from pathlib import Path

        copied_files = []

        try:
            unc_source = Path(unc_path)
            output_path = Path(output_dir)

            # Check if UNC path is accessible
            if not unc_source.exists():
                return copied_files  # Return empty list if UNC path not accessible

            # Walk through the UNC directory tree
            for root, dirs, files in os.walk(unc_source):
                root_path = Path(root)

                # Calculate relative path from the UNC source
                try:
                    rel_path = root_path.relative_to(unc_source)
                except ValueError:
                    # Skip if we can't determine relative path
                    continue

                for filename in files:
                    # Only copy .zip and .dmp files
                    if filename.lower().endswith(('.zip', '.dmp')):
                        source_file = root_path / filename

                        # Create destination path preserving directory structure
                        dest_dir = output_path / rel_path
                        dest_dir.mkdir(parents=True, exist_ok=True)
                        dest_file = dest_dir / filename

                        # Copy the file
                        try:
                            shutil.copy2(source_file, dest_file)
                            copied_files.append(filename)
                        except Exception:
                            # Skip files that fail to copy
                            continue

        except Exception:
            # Silently skip if any errors occur accessing UNC path
            pass

        return copied_files

    def get_build_version(self, build_id: int) -> Optional[str]:
        """
        Extract the build version from 'Get Version' job logs.
        Looks for a line like "Build Number 25.9.44.0"
        """
        import re

        timeline = self.get_build_timeline(build_id)

        # Find the "Get build info" task in the "Get Version" job
        for record in timeline.get('records', []):
            if record.get('type') == 'Task':
                task_name = record.get('name', '')
                if 'Get build info' in task_name:
                    log_ref = record.get('log', {})
                    log_id = log_ref.get('id')

                    if log_id:
                        try:
                            log_lines = self.get_build_logs(build_id, log_id)

                            # Search for "Build Number X.X.X.X"
                            for line in log_lines:
                                match = re.search(r'Build Number (\d+\.\d+\.\d+\.\d+)', line)
                                if match:
                                    return match.group(1)
                        except Exception:
                            continue

        return None

    def find_build_by_version(self, version: str) -> Optional[int]:
        """
        Search FullBuild and FeatureBuild pipelines for a build with matching version.
        Returns the build ID if found.
        """
        pipeline_names = ["FullBuild", "FeatureBuild"]

        for pipeline_name in pipeline_names:
            # Find pipeline ID
            pipeline_id = self.find_pipeline_by_name(pipeline_name)
            if not pipeline_id:
                continue

            # Get recent builds (search up to 100)
            try:
                builds = self.get_pipeline_runs(pipeline_id, top=100)

                for build in builds:
                    build_number = build.get('buildNumber', '')
                    # Check if version is in the build number
                    if version in build_number:
                        return build['id']
            except Exception:
                continue

        return None

    def recursive_unzip(self, zip_path: str, output_dir: str):
        """
        Recursively extract zip files. If a zip contains another zip, extract it too.
        """
        import zipfile
        import os
        from pathlib import Path

        output_path = Path(output_dir)
        zip_file_path = Path(zip_path)

        if not zip_file_path.exists():
            return

        try:
            with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
                zip_ref.extractall(output_path)

            # Find any nested zip files and extract them
            for root, dirs, files in os.walk(output_path):
                root_path = Path(root)
                for filename in files:
                    if filename.lower().endswith('.zip'):
                        nested_zip = root_path / filename
                        # Extract in the same directory as the zip file
                        extract_dir = root_path
                        try:
                            self.recursive_unzip(str(nested_zip), str(extract_dir))
                            # Remove the zip file after extraction
                            nested_zip.unlink()
                        except Exception:
                            # Skip if extraction fails
                            continue

        except Exception:
            # Skip if extraction fails
            pass

    def download_service_symbols(self, build_id: int, output_dir: str):
        """
        Download _ServiceSymbols artifact from a build and extract to pdbs/ folder.
        """
        from pathlib import Path
        import tempfile

        output_path = Path(output_dir)
        pdbs_dir = output_path / 'pdbs'
        pdbs_dir.mkdir(parents=True, exist_ok=True)

        try:
            # Get build artifacts
            artifacts_url = (
                f"{self.org_url}/{self.project}/_apis/build/builds/{build_id}/"
                f"artifacts?api-version=6.0"
            )
            artifacts_data = self.make_request(artifacts_url)

            # Find _ServiceSymbols artifact
            service_symbols_url = None
            for artifact in artifacts_data.get('value', []):
                if artifact.get('name') == '_ServiceSymbols':
                    service_symbols_url = artifact.get('resource', {}).get('downloadUrl')
                    break

            if not service_symbols_url:
                return  # No symbols artifact found

            # Download the artifact
            response = self.session.get(service_symbols_url, timeout=300)
            response.raise_for_status()

            # Save to temporary file
            with tempfile.NamedTemporaryFile(delete=False, suffix='.zip') as tmp_file:
                tmp_file.write(response.content)
                tmp_path = tmp_file.name

            # Recursively extract
            self.recursive_unzip(tmp_path, str(pdbs_dir))

            # Clean up temp file
            Path(tmp_path).unlink()

        except Exception:
            # Silently skip if download or extraction fails
            pass

    def create_windows_shortcut(self, unc_path: str, output_dir: str, endpoint: Optional[str] = None):
        """
        Create Windows shortcut files to the UNC path.
        Creates both a .bat file and a .txt file for compatibility.
        If endpoint is provided, it will be appended to the UNC path.
        """
        from pathlib import Path

        output_path = Path(output_dir)

        # Append endpoint to UNC path if provided
        if endpoint:
            full_unc_path = f"{unc_path}\\{endpoint}"
        else:
            full_unc_path = unc_path

        # Create a batch file that opens the UNC path in Windows Explorer
        bat_file = output_path / "Open_Test_Results.bat"
        with open(bat_file, 'w') as f:
            f.write(f'@echo off\n')
            f.write(f'start "" "{full_unc_path}"\n')

        # Create a text file with the UNC path for easy copying
        txt_file = output_path / "UNC_Path.txt"
        with open(txt_file, 'w') as f:
            f.write(f'Test Results Location:\n')
            f.write(f'{full_unc_path}\n')

    def download_test_logs(self, run_id: int, result_id: int, build_id: int, test_name: str, unc_path: Optional[str] = None) -> str:
        """Download logs for a failed test to ~/testruns/<buildid>/<testname>/"""
        import re
        from pathlib import Path

        # Sanitize test name for filesystem
        safe_test_name = re.sub(r'[^\w\-_\. ]', '_', test_name)
        safe_test_name = safe_test_name.replace(' ', '_')

        # Create directory structure
        output_dir = Path.home() / 'testruns' / str(build_id) / safe_test_name
        output_dir.mkdir(parents=True, exist_ok=True)

        # Get test result details with attachments
        result_url = (
            f"{self.org_url}/{self.project}/_apis/test/Runs/{run_id}/"
            f"Results/{result_id}?detailsToInclude=SubResults&api-version=7.0"
        )

        try:
            result_data = self.make_request(result_url)

            # Save test result details
            import json
            with open(output_dir / 'result.json', 'w') as f:
                json.dump(result_data, f, indent=2)

            # Get attachments
            attachments_url = (
                f"{self.org_url}/{self.project}/_apis/test/Runs/{run_id}/"
                f"Results/{result_id}/attachments?api-version=7.0"
            )

            attachments_data = self.make_request(attachments_url)

            # Download each attachment
            for attachment in attachments_data.get('value', []):
                attachment_id = attachment.get('id')
                attachment_name = attachment.get('fileName', f'attachment_{attachment_id}')

                attachment_url = (
                    f"{self.org_url}/{self.project}/_apis/test/Runs/{run_id}/"
                    f"Results/{result_id}/attachments/{attachment_id}?api-version=7.0"
                )

                response = self.session.get(attachment_url, timeout=120)
                response.raise_for_status()

                # Save attachment
                with open(output_dir / attachment_name, 'wb') as f:
                    f.write(response.content)

            # Also save error message to a text file
            if result_data.get('errorMessage'):
                with open(output_dir / 'error.txt', 'w') as f:
                    f.write(result_data['errorMessage'])

            # Create Windows shortcut to UNC path if provided
            if unc_path:
                # Extract endpoint (computer name) from result data
                endpoint = result_data.get('computerName')
                self.create_windows_shortcut(unc_path, str(output_dir), endpoint)

                # Copy .zip and .dmp files from UNC path if endpoint is available
                if endpoint:
                    full_unc_path = f"{unc_path}\\{endpoint}"
                    copied_files = self.copy_unc_artifacts(full_unc_path, str(output_dir))

                    # If any .dmp files were copied, download symbols
                    has_dmp = any(f.lower().endswith('.dmp') for f in copied_files)
                    if has_dmp:
                        # Get build version from the regression run
                        build_version = self.get_build_version(build_id)
                        if build_version:
                            # Find the matching FullBuild or FeatureBuild
                            symbols_build_id = self.find_build_by_version(build_version)
                            if symbols_build_id:
                                # Download and extract symbols
                                self.download_service_symbols(symbols_build_id, str(output_dir))

            return str(output_dir)

        except Exception as e:
            raise Exception(f"Failed to download logs: {str(e)}")


class CursesUI:
    """Handles curses UI for displaying pipeline runs and test failures."""

    def __init__(self, stdscr):
        """Initialize curses UI."""
        self.stdscr = stdscr
        self.current_selection = 0
        self.scroll_offset = 0

        # Initialize colors
        curses.start_color()
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)  # Selected
        curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)  # Success
        curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK)    # Failed
        curses.init_pair(4, curses.COLOR_YELLOW, curses.COLOR_BLACK) # In Progress
        curses.init_pair(5, curses.COLOR_CYAN, curses.COLOR_BLACK)   # Header

        # Cursor and input settings
        curses.curs_set(0)  # Hide cursor
        self.stdscr.keypad(True)

    def get_status_color(self, status: str, result: str) -> int:
        """Get color pair for build status."""
        if result == "succeeded":
            return 2  # Green
        elif result == "failed":
            return 3  # Red
        elif status == "inProgress":
            return 4  # Yellow
        return 0  # Default

    def draw_runs_list(self, runs: List[Dict[str, Any]], pipeline_name: str):
        """Draw the list of pipeline runs."""
        self.stdscr.clear()
        height, width = self.stdscr.getmaxyx()

        # Header
        header = f"RunRegression Pipeline Runs ({pipeline_name})"
        self.stdscr.addstr(0, 0, header[:width-1], curses.color_pair(5) | curses.A_BOLD)
        self.stdscr.addstr(
            1, 0,
            "Use arrow keys to navigate, Enter to view failures, Q to quit"[:width-1],
            curses.color_pair(5)
        )

        # Column headers
        header_line = f"{'#':<5} {'Build':<15} {'Status':<12} {'Result':<12} {'Started':<20} {'Branch':<30}"
        self.stdscr.addstr(3, 0, header_line[:width-1], curses.A_BOLD)

        # Calculate visible range
        visible_height = height - 6  # Account for header and footer
        max_scroll = max(0, len(runs) - visible_height)
        self.scroll_offset = max(0, min(self.scroll_offset, max_scroll))

        # Adjust scroll if selection is out of view
        if self.current_selection < self.scroll_offset:
            self.scroll_offset = self.current_selection
        elif self.current_selection >= self.scroll_offset + visible_height:
            self.scroll_offset = self.current_selection - visible_height + 1

        # Draw visible runs
        for idx in range(visible_height):
            run_idx = idx + self.scroll_offset
            if run_idx >= len(runs):
                break

            run = runs[run_idx]

            # Format run data
            build_num = run.get('buildNumber', 'N/A')[:15]
            status = run.get('status', 'unknown')[:12]
            result = run.get('result', 'N/A')[:12]
            start_time = run.get('startTime', '')
            if start_time:
                try:
                    dt = datetime.fromisoformat(start_time.replace('Z', '+00:00'))
                    start_time = dt.strftime('%Y-%m-%d %H:%M')
                except:
                    start_time = start_time[:20]
            branch = run.get('sourceBranch', '')
            if branch.startswith('refs/heads/'):
                branch = branch[11:]
            branch = branch[:30]

            line = f"{run_idx+1:<5} {build_num:<15} {status:<12} {result:<12} {start_time:<20} {branch:<30}"

            # Apply colors and highlight selection
            y_pos = 4 + idx
            if run_idx == self.current_selection:
                self.stdscr.addstr(y_pos, 0, line[:width-1], curses.color_pair(1))
            else:
                color = self.get_status_color(status, result)
                self.stdscr.addstr(y_pos, 0, line[:width-1], curses.color_pair(color))

        # Footer with scroll indicator
        footer = f"Showing {self.scroll_offset + 1}-{min(self.scroll_offset + visible_height, len(runs))} of {len(runs)}"
        self.stdscr.addstr(height - 1, 0, footer[:width-1], curses.color_pair(5))

        self.stdscr.refresh()

    def draw_failures_list(self, failures: List[Dict[str, Any]], build_number: str,
                          test_selection: int, test_scroll: int):
        """Draw the list of failed tests with selection support."""
        self.stdscr.clear()
        height, width = self.stdscr.getmaxyx()

        # Header
        header = f"Failed Tests for Build {build_number}"
        self.stdscr.addstr(0, 0, header[:width-1], curses.color_pair(5) | curses.A_BOLD)
        self.stdscr.addstr(
            1, 0,
            "Use arrow keys, Enter to download logs, Q/Esc to return"[:width-1],
            curses.color_pair(5)
        )

        if not failures:
            self.stdscr.addstr(3, 0, "No failed tests found!", curses.color_pair(2))
            self.stdscr.refresh()
            return

        # Calculate visible range
        visible_height = height - 5  # Account for header and footer

        # Draw visible failures
        y_pos = 3
        for idx in range(visible_height):
            test_idx = idx + test_scroll
            if test_idx >= len(failures):
                break

            failure = failures[test_idx]
            test_line = f"{failure['run']}: {failure['test']}"

            # Highlight selection
            if test_idx == test_selection:
                self.stdscr.addstr(y_pos, 0, test_line[:width-1], curses.color_pair(1))
            else:
                self.stdscr.addstr(y_pos, 0, test_line[:width-1], curses.color_pair(3))

            y_pos += 1

        # Summary footer
        total_failures = len(failures)
        summary = f"Showing {test_scroll + 1}-{min(test_scroll + visible_height, total_failures)} of {total_failures} failed tests"
        self.stdscr.addstr(height - 1, 0, summary[:width-1], curses.color_pair(5) | curses.A_BOLD)

        self.stdscr.refresh()

    def select_failed_test(self, failures: List[Dict[str, Any]], build_number: str) -> Optional[Dict[str, Any]]:
        """Handle failed test selection with arrow keys."""
        test_selection = 0
        test_scroll = 0

        if not failures:
            self.draw_failures_list(failures, build_number, 0, 0)
            self.stdscr.getch()
            return None

        height, _ = self.stdscr.getmaxyx()
        visible_height = height - 5

        while True:
            # Adjust scroll if selection is out of view
            if test_selection < test_scroll:
                test_scroll = test_selection
            elif test_selection >= test_scroll + visible_height:
                test_scroll = test_selection - visible_height + 1

            self.draw_failures_list(failures, build_number, test_selection, test_scroll)

            key = self.stdscr.getch()

            if key == curses.KEY_UP:
                test_selection = max(0, test_selection - 1)
            elif key == curses.KEY_DOWN:
                test_selection = min(len(failures) - 1, test_selection + 1)
            elif key == ord('\n') or key == curses.KEY_ENTER:
                return failures[test_selection]
            elif key == ord('q') or key == ord('Q') or key == 27:  # 27 is ESC
                return None

    def select_run(self, runs: List[Dict[str, Any]], pipeline_name: str) -> Optional[Dict[str, Any]]:
        """Handle run selection with arrow keys."""
        while True:
            self.draw_runs_list(runs, pipeline_name)

            key = self.stdscr.getch()

            if key == curses.KEY_UP:
                self.current_selection = max(0, self.current_selection - 1)
            elif key == curses.KEY_DOWN:
                self.current_selection = min(len(runs) - 1, self.current_selection + 1)
            elif key == ord('\n') or key == curses.KEY_ENTER:
                return runs[self.current_selection]
            elif key == ord('q') or key == ord('Q'):
                return None


def main(stdscr):
    """Main entry point for the curses UI."""
    try:
        # Initialize Azure DevOps connection
        azdo = AzDoConnection()

        # Find RunRegression pipeline
        pipeline_name = "RunRegression"
        pipeline_id = azdo.find_pipeline_by_name(pipeline_name)

        if pipeline_id is None:
            stdscr.addstr(0, 0, f"Error: Pipeline '{pipeline_name}' not found!")
            stdscr.addstr(1, 0, "Press any key to exit...")
            stdscr.getch()
            return

        # Get pipeline runs
        stdscr.addstr(0, 0, "Loading pipeline runs...")
        stdscr.refresh()

        runs = azdo.get_pipeline_runs(pipeline_id)

        if not runs:
            stdscr.addstr(0, 0, "No runs found for this pipeline!")
            stdscr.addstr(1, 0, "Press any key to exit...")
            stdscr.getch()
            return

        # Initialize UI
        ui = CursesUI(stdscr)

        # Main loop
        while True:
            selected_run = ui.select_run(runs, pipeline_name)

            if selected_run is None:
                break  # User quit

            # Show loading message
            stdscr.clear()
            stdscr.addstr(0, 0, "Loading test failures...")
            stdscr.refresh()

            # Get failed tests
            build_id = selected_run['id']
            build_number = selected_run.get('buildNumber', str(build_id))
            failures = azdo.get_failed_tests(build_id)

            # Silently parse copy job logs to get UNC paths
            test_suite_paths = azdo.parse_copy_job_logs(build_id)

            # Test selection loop
            while True:
                selected_test = ui.select_failed_test(failures, build_number)

                if selected_test is None:
                    break  # User went back

                # Show downloading message
                stdscr.clear()
                stdscr.addstr(0, 0, f"Downloading logs for: {selected_test['test']}")
                stdscr.addstr(1, 0, "Please wait...")
                stdscr.refresh()

                # Download logs
                try:
                    # Find matching UNC path for this test suite
                    unc_path = None
                    run_name = selected_test['run']
                    for suite_name, path in test_suite_paths.items():
                        if suite_name in run_name:
                            unc_path = path
                            break

                    output_dir = azdo.download_test_logs(
                        selected_test['run_id'],
                        selected_test['result_id'],
                        build_id,
                        selected_test['test'],
                        unc_path
                    )

                    # Show success message
                    stdscr.clear()
                    stdscr.addstr(0, 0, "Logs downloaded successfully!", curses.color_pair(2))
                    stdscr.addstr(1, 0, f"Location: {output_dir}")
                    stdscr.addstr(3, 0, "Press any key to continue...")
                    stdscr.refresh()
                    stdscr.getch()

                except Exception as e:
                    # Show error message
                    stdscr.clear()
                    stdscr.addstr(0, 0, "Error downloading logs:", curses.color_pair(3))
                    stdscr.addstr(1, 0, str(e)[:stdscr.getmaxyx()[1] - 1])
                    stdscr.addstr(3, 0, "Press any key to continue...")
                    stdscr.refresh()
                    stdscr.getch()

    except Exception as e:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Error: {str(e)}")
        stdscr.addstr(1, 0, "Press any key to exit...")
        stdscr.refresh()
        stdscr.getch()


if __name__ == "__main__":
    try:
        curses.wrapper(main)
    except KeyboardInterrupt:
        print("\nExited by user")
        sys.exit(0)
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
