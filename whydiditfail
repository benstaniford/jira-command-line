#!/usr/bin/env python3
"""
Azure DevOps RunRegression Pipeline Viewer
Shows pipeline runs and their failed tests using curses UI.
"""

import curses
import os
import sys
import requests
from requests.auth import HTTPBasicAuth
from base64 import b64encode
from typing import List, Dict, Any, Optional
from datetime import datetime


class AzDoConnection:
    """Handles Azure DevOps API connection and requests."""

    def __init__(self):
        """Initialize connection using environment variables."""
        self.pat_token = os.getenv("AZURE_DEVOPS_EXT_PAT")
        self.org_url = os.getenv("AZ_ORG")
        self.project = os.getenv("AZ_PROJECT")

        if not all([self.pat_token, self.org_url, self.project]):
            raise ValueError(
                "Missing required environment variables: "
                "AZURE_DEVOPS_EXT_PAT, AZ_ORG, AZ_PROJECT"
            )

        # Create authenticated session
        self.session = requests.Session()
        self.session.auth = HTTPBasicAuth("", self.pat_token)
        self.session.headers.update({
            "Content-Type": "application/json",
            "Accept": "application/json"
        })

    def make_request(self, url: str) -> Dict[str, Any]:
        """Make an authenticated GET request to Azure DevOps API."""
        response = self.session.get(url, timeout=120)
        response.raise_for_status()
        return response.json()

    def find_pipeline_by_name(self, name: str) -> Optional[int]:
        """Find a pipeline ID by name."""
        url = f"{self.org_url}/{self.project}/_apis/build/definitions?api-version=6.0"
        data = self.make_request(url)

        for pipeline in data.get("value", []):
            if pipeline["name"] == name:
                return pipeline["id"]

        return None

    def get_pipeline_runs(self, pipeline_id: int, top: int = 50) -> List[Dict[str, Any]]:
        """Get recent runs for a pipeline."""
        url = (
            f"{self.org_url}/{self.project}/_apis/build/builds?"
            f"definitions={pipeline_id}&$top={top}&api-version=6.0"
        )
        data = self.make_request(url)
        return data.get("value", [])

    def get_failed_tests(self, build_id: int) -> List[Dict[str, Any]]:
        """Get failed tests for a build, similar to get_portal_failures.py."""
        # Default filters for specific test suites
        default_filters = [
            'EventAuditLegacy',
            'EventAuditJson',
            'Filters',
            'Identity',
            'Messaging',
            'Utilities'
        ]

        # Get test runs for the build
        runs_url = (
            f"{self.org_url}/{self.project}/_apis/test/runs?"
            f"buildIds={build_id}&api-version=7.0"
        )

        runs_data = self.make_request(runs_url)

        if not runs_data.get('value'):
            return []

        # Filter to only completed runs
        completed_runs = [
            r for r in runs_data['value']
            if r.get('state') == 'Completed'
        ]

        # Group by run name and get the one with highest ID (most recent)
        latest_runs = {}
        for run in completed_runs:
            run_name = run.get('name', 'Unknown')
            run_id = run['id']

            # Apply default filters - only include specified test suites
            if not any(f in run_name for f in default_filters):
                continue

            # Keep the run with the highest ID for each name
            if run_name not in latest_runs or run_id > latest_runs[run_name]['id']:
                latest_runs[run_name] = run

        # Get failures from each run
        all_failures = []

        for run_name in sorted(latest_runs.keys()):
            run = latest_runs[run_name]
            run_id = run['id']

            # Get failed test results for this run
            results_url = (
                f"{self.org_url}/{self.project}/_apis/test/Runs/{run_id}/results?"
                f"outcomes=Failed&$top=1000&api-version=7.0"
            )

            try:
                results_data = self.make_request(results_url)
            except requests.exceptions.Timeout:
                continue

            # Count actual failures
            for result in results_data.get('value', []):
                outcome = result.get('outcome', '')

                # Only include tests with outcome exactly "Failed"
                if outcome != 'Failed':
                    continue

                test_name = result.get(
                    'testCaseTitle',
                    result.get('automatedTestName', 'Unknown')
                )
                error_message = result.get('errorMessage', '')

                all_failures.append({
                    'run': run_name,
                    'test': test_name,
                    'run_id': run_id,
                    'error': error_message
                })

        return all_failures


class CursesUI:
    """Handles curses UI for displaying pipeline runs and test failures."""

    def __init__(self, stdscr):
        """Initialize curses UI."""
        self.stdscr = stdscr
        self.current_selection = 0
        self.scroll_offset = 0

        # Initialize colors
        curses.start_color()
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)  # Selected
        curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)  # Success
        curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK)    # Failed
        curses.init_pair(4, curses.COLOR_YELLOW, curses.COLOR_BLACK) # In Progress
        curses.init_pair(5, curses.COLOR_CYAN, curses.COLOR_BLACK)   # Header

        # Cursor and input settings
        curses.curs_set(0)  # Hide cursor
        self.stdscr.keypad(True)

    def get_status_color(self, status: str, result: str) -> int:
        """Get color pair for build status."""
        if result == "succeeded":
            return 2  # Green
        elif result == "failed":
            return 3  # Red
        elif status == "inProgress":
            return 4  # Yellow
        return 0  # Default

    def draw_runs_list(self, runs: List[Dict[str, Any]], pipeline_name: str):
        """Draw the list of pipeline runs."""
        self.stdscr.clear()
        height, width = self.stdscr.getmaxyx()

        # Header
        header = f"RunRegression Pipeline Runs ({pipeline_name})"
        self.stdscr.addstr(0, 0, header[:width-1], curses.color_pair(5) | curses.A_BOLD)
        self.stdscr.addstr(
            1, 0,
            "Use arrow keys to navigate, Enter to view failures, Q to quit"[:width-1],
            curses.color_pair(5)
        )

        # Column headers
        header_line = f"{'#':<5} {'Build':<15} {'Status':<12} {'Result':<12} {'Started':<20} {'Branch':<30}"
        self.stdscr.addstr(3, 0, header_line[:width-1], curses.A_BOLD)

        # Calculate visible range
        visible_height = height - 6  # Account for header and footer
        max_scroll = max(0, len(runs) - visible_height)
        self.scroll_offset = max(0, min(self.scroll_offset, max_scroll))

        # Adjust scroll if selection is out of view
        if self.current_selection < self.scroll_offset:
            self.scroll_offset = self.current_selection
        elif self.current_selection >= self.scroll_offset + visible_height:
            self.scroll_offset = self.current_selection - visible_height + 1

        # Draw visible runs
        for idx in range(visible_height):
            run_idx = idx + self.scroll_offset
            if run_idx >= len(runs):
                break

            run = runs[run_idx]

            # Format run data
            build_num = run.get('buildNumber', 'N/A')[:15]
            status = run.get('status', 'unknown')[:12]
            result = run.get('result', 'N/A')[:12]
            start_time = run.get('startTime', '')
            if start_time:
                try:
                    dt = datetime.fromisoformat(start_time.replace('Z', '+00:00'))
                    start_time = dt.strftime('%Y-%m-%d %H:%M')
                except:
                    start_time = start_time[:20]
            branch = run.get('sourceBranch', '')
            if branch.startswith('refs/heads/'):
                branch = branch[11:]
            branch = branch[:30]

            line = f"{run_idx+1:<5} {build_num:<15} {status:<12} {result:<12} {start_time:<20} {branch:<30}"

            # Apply colors and highlight selection
            y_pos = 4 + idx
            if run_idx == self.current_selection:
                self.stdscr.addstr(y_pos, 0, line[:width-1], curses.color_pair(1))
            else:
                color = self.get_status_color(status, result)
                self.stdscr.addstr(y_pos, 0, line[:width-1], curses.color_pair(color))

        # Footer with scroll indicator
        footer = f"Showing {self.scroll_offset + 1}-{min(self.scroll_offset + visible_height, len(runs))} of {len(runs)}"
        self.stdscr.addstr(height - 1, 0, footer[:width-1], curses.color_pair(5))

        self.stdscr.refresh()

    def draw_failures_list(self, failures: List[Dict[str, Any]], build_number: str):
        """Draw the list of failed tests."""
        self.stdscr.clear()
        height, width = self.stdscr.getmaxyx()

        # Header
        header = f"Failed Tests for Build {build_number}"
        self.stdscr.addstr(0, 0, header[:width-1], curses.color_pair(5) | curses.A_BOLD)
        self.stdscr.addstr(
            1, 0,
            "Press any key to return"[:width-1],
            curses.color_pair(5)
        )

        if not failures:
            self.stdscr.addstr(3, 0, "No failed tests found!", curses.color_pair(2))
            self.stdscr.refresh()
            self.stdscr.getch()
            return

        # Group failures by run
        runs_dict = {}
        for failure in failures:
            run_name = failure['run']
            if run_name not in runs_dict:
                runs_dict[run_name] = []
            runs_dict[run_name].append(failure)

        # Draw failures
        y_pos = 3
        for run_name in sorted(runs_dict.keys()):
            if y_pos >= height - 2:
                break

            # Run name header
            run_header = f"{run_name}: {len(runs_dict[run_name])} failure(s)"
            self.stdscr.addstr(y_pos, 0, run_header[:width-1], curses.A_BOLD | curses.color_pair(3))
            y_pos += 1

            # List failures
            for failure in runs_dict[run_name]:
                if y_pos >= height - 2:
                    break
                test_name = failure['test']
                self.stdscr.addstr(y_pos, 2, f"- {test_name}"[:width-3], curses.color_pair(3))
                y_pos += 1

            y_pos += 1  # Blank line between runs

        # Summary footer
        total_failures = len(failures)
        total_runs = len(runs_dict)
        summary = f"TOTAL: {total_failures} failed tests across {total_runs} suites"
        self.stdscr.addstr(height - 1, 0, summary[:width-1], curses.color_pair(5) | curses.A_BOLD)

        self.stdscr.refresh()
        self.stdscr.getch()

    def select_run(self, runs: List[Dict[str, Any]], pipeline_name: str) -> Optional[Dict[str, Any]]:
        """Handle run selection with arrow keys."""
        while True:
            self.draw_runs_list(runs, pipeline_name)

            key = self.stdscr.getch()

            if key == curses.KEY_UP:
                self.current_selection = max(0, self.current_selection - 1)
            elif key == curses.KEY_DOWN:
                self.current_selection = min(len(runs) - 1, self.current_selection + 1)
            elif key == ord('\n') or key == curses.KEY_ENTER:
                return runs[self.current_selection]
            elif key == ord('q') or key == ord('Q'):
                return None


def main(stdscr):
    """Main entry point for the curses UI."""
    try:
        # Initialize Azure DevOps connection
        azdo = AzDoConnection()

        # Find RunRegression pipeline
        pipeline_name = "RunRegression"
        pipeline_id = azdo.find_pipeline_by_name(pipeline_name)

        if pipeline_id is None:
            stdscr.addstr(0, 0, f"Error: Pipeline '{pipeline_name}' not found!")
            stdscr.addstr(1, 0, "Press any key to exit...")
            stdscr.getch()
            return

        # Get pipeline runs
        stdscr.addstr(0, 0, "Loading pipeline runs...")
        stdscr.refresh()

        runs = azdo.get_pipeline_runs(pipeline_id)

        if not runs:
            stdscr.addstr(0, 0, "No runs found for this pipeline!")
            stdscr.addstr(1, 0, "Press any key to exit...")
            stdscr.getch()
            return

        # Initialize UI
        ui = CursesUI(stdscr)

        # Main loop
        while True:
            selected_run = ui.select_run(runs, pipeline_name)

            if selected_run is None:
                break  # User quit

            # Show loading message
            stdscr.clear()
            stdscr.addstr(0, 0, "Loading test failures...")
            stdscr.refresh()

            # Get failed tests
            build_id = selected_run['id']
            build_number = selected_run.get('buildNumber', str(build_id))
            failures = azdo.get_failed_tests(build_id)

            # Display failures
            ui.draw_failures_list(failures, build_number)

    except Exception as e:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Error: {str(e)}")
        stdscr.addstr(1, 0, "Press any key to exit...")
        stdscr.refresh()
        stdscr.getch()


if __name__ == "__main__":
    try:
        curses.wrapper(main)
    except KeyboardInterrupt:
        print("\nExited by user")
        sys.exit(0)
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
