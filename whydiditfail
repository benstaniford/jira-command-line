#!/usr/bin/env python3
"""
Azure DevOps RunRegression Pipeline Viewer
Shows pipeline runs and their failed tests using curses UI.
"""

import curses
import os
import sys
import requests
from requests.auth import HTTPBasicAuth
from base64 import b64encode
from typing import List, Dict, Any, Optional
from datetime import datetime


class AzDoConnection:
    """Handles Azure DevOps API connection and requests."""

    def __init__(self):
        """Initialize connection using environment variables."""
        self.pat_token = os.getenv("AZURE_DEVOPS_EXT_PAT")
        self.org_url = os.getenv("AZ_ORG")
        self.project = os.getenv("AZ_PROJECT")

        if not all([self.pat_token, self.org_url, self.project]):
            raise ValueError(
                "Missing required environment variables: "
                "AZURE_DEVOPS_EXT_PAT, AZ_ORG, AZ_PROJECT"
            )

        # Create authenticated session
        self.session = requests.Session()
        self.session.auth = HTTPBasicAuth("", self.pat_token)
        self.session.headers.update({
            "Content-Type": "application/json",
            "Accept": "application/json"
        })

    def make_request(self, url: str) -> Dict[str, Any]:
        """Make an authenticated GET request to Azure DevOps API."""
        response = self.session.get(url, timeout=120)
        response.raise_for_status()
        return response.json()

    def find_pipeline_by_name(self, name: str) -> Optional[int]:
        """Find a pipeline ID by name."""
        url = f"{self.org_url}/{self.project}/_apis/build/definitions?api-version=6.0"
        data = self.make_request(url)

        for pipeline in data.get("value", []):
            if pipeline["name"] == name:
                return pipeline["id"]

        return None

    def get_pipeline_runs(self, pipeline_id: int, top: int = 50) -> List[Dict[str, Any]]:
        """Get recent runs for a pipeline."""
        url = (
            f"{self.org_url}/{self.project}/_apis/build/builds?"
            f"definitions={pipeline_id}&$top={top}&api-version=6.0"
        )
        data = self.make_request(url)
        return data.get("value", [])

    def get_failed_tests(self, build_id: int) -> List[Dict[str, Any]]:
        """Get failed tests for a build, similar to get_portal_failures.py."""
        # Default filters for specific test suites
        default_filters = [
            'EventAuditLegacy',
            'EventAuditJson',
            'Filters',
            'Identity',
            'Messaging',
            'Utilities'
        ]

        # Get test runs for the build
        runs_url = (
            f"{self.org_url}/{self.project}/_apis/test/runs?"
            f"buildIds={build_id}&api-version=7.0"
        )

        runs_data = self.make_request(runs_url)

        if not runs_data.get('value'):
            return []

        # Filter to only completed runs
        completed_runs = [
            r for r in runs_data['value']
            if r.get('state') == 'Completed'
        ]

        # Group by run name and get the one with highest ID (most recent)
        latest_runs = {}
        for run in completed_runs:
            run_name = run.get('name', 'Unknown')
            run_id = run['id']

            # Apply default filters - only include specified test suites
            if not any(f in run_name for f in default_filters):
                continue

            # Keep the run with the highest ID for each name
            if run_name not in latest_runs or run_id > latest_runs[run_name]['id']:
                latest_runs[run_name] = run

        # Get failures from each run
        all_failures = []

        for run_name in sorted(latest_runs.keys()):
            run = latest_runs[run_name]
            run_id = run['id']

            # Get failed test results for this run
            results_url = (
                f"{self.org_url}/{self.project}/_apis/test/Runs/{run_id}/results?"
                f"outcomes=Failed&$top=1000&api-version=7.0"
            )

            try:
                results_data = self.make_request(results_url)
            except requests.exceptions.Timeout:
                continue

            # Count actual failures
            for result in results_data.get('value', []):
                outcome = result.get('outcome', '')

                # Only include tests with outcome exactly "Failed"
                if outcome != 'Failed':
                    continue

                test_name = result.get(
                    'testCaseTitle',
                    result.get('automatedTestName', 'Unknown')
                )
                error_message = result.get('errorMessage', '')

                all_failures.append({
                    'run': run_name,
                    'test': test_name,
                    'run_id': run_id,
                    'result_id': result['id'],
                    'error': error_message
                })

        return all_failures

    def download_test_logs(self, run_id: int, result_id: int, build_id: int, test_name: str) -> str:
        """Download logs for a failed test to ~/testruns/<buildid>/<testname>/"""
        import re
        from pathlib import Path

        # Sanitize test name for filesystem
        safe_test_name = re.sub(r'[^\w\-_\. ]', '_', test_name)
        safe_test_name = safe_test_name.replace(' ', '_')

        # Create directory structure
        output_dir = Path.home() / 'testruns' / str(build_id) / safe_test_name
        output_dir.mkdir(parents=True, exist_ok=True)

        # Get test result details with attachments
        result_url = (
            f"{self.org_url}/{self.project}/_apis/test/Runs/{run_id}/"
            f"Results/{result_id}?detailsToInclude=SubResults&api-version=7.0"
        )

        try:
            result_data = self.make_request(result_url)

            # Save test result details
            import json
            with open(output_dir / 'result.json', 'w') as f:
                json.dump(result_data, f, indent=2)

            # Get attachments
            attachments_url = (
                f"{self.org_url}/{self.project}/_apis/test/Runs/{run_id}/"
                f"Results/{result_id}/attachments?api-version=7.0"
            )

            attachments_data = self.make_request(attachments_url)

            # Download each attachment
            for attachment in attachments_data.get('value', []):
                attachment_id = attachment.get('id')
                attachment_name = attachment.get('fileName', f'attachment_{attachment_id}')

                attachment_url = (
                    f"{self.org_url}/{self.project}/_apis/test/Runs/{run_id}/"
                    f"Results/{result_id}/attachments/{attachment_id}?api-version=7.0"
                )

                response = self.session.get(attachment_url, timeout=120)
                response.raise_for_status()

                # Save attachment
                with open(output_dir / attachment_name, 'wb') as f:
                    f.write(response.content)

            # Also save error message to a text file
            if result_data.get('errorMessage'):
                with open(output_dir / 'error.txt', 'w') as f:
                    f.write(result_data['errorMessage'])

            return str(output_dir)

        except Exception as e:
            raise Exception(f"Failed to download logs: {str(e)}")


class CursesUI:
    """Handles curses UI for displaying pipeline runs and test failures."""

    def __init__(self, stdscr):
        """Initialize curses UI."""
        self.stdscr = stdscr
        self.current_selection = 0
        self.scroll_offset = 0

        # Initialize colors
        curses.start_color()
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)  # Selected
        curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)  # Success
        curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK)    # Failed
        curses.init_pair(4, curses.COLOR_YELLOW, curses.COLOR_BLACK) # In Progress
        curses.init_pair(5, curses.COLOR_CYAN, curses.COLOR_BLACK)   # Header

        # Cursor and input settings
        curses.curs_set(0)  # Hide cursor
        self.stdscr.keypad(True)

    def get_status_color(self, status: str, result: str) -> int:
        """Get color pair for build status."""
        if result == "succeeded":
            return 2  # Green
        elif result == "failed":
            return 3  # Red
        elif status == "inProgress":
            return 4  # Yellow
        return 0  # Default

    def draw_runs_list(self, runs: List[Dict[str, Any]], pipeline_name: str):
        """Draw the list of pipeline runs."""
        self.stdscr.clear()
        height, width = self.stdscr.getmaxyx()

        # Header
        header = f"RunRegression Pipeline Runs ({pipeline_name})"
        self.stdscr.addstr(0, 0, header[:width-1], curses.color_pair(5) | curses.A_BOLD)
        self.stdscr.addstr(
            1, 0,
            "Use arrow keys to navigate, Enter to view failures, Q to quit"[:width-1],
            curses.color_pair(5)
        )

        # Column headers
        header_line = f"{'#':<5} {'Build':<15} {'Status':<12} {'Result':<12} {'Started':<20} {'Branch':<30}"
        self.stdscr.addstr(3, 0, header_line[:width-1], curses.A_BOLD)

        # Calculate visible range
        visible_height = height - 6  # Account for header and footer
        max_scroll = max(0, len(runs) - visible_height)
        self.scroll_offset = max(0, min(self.scroll_offset, max_scroll))

        # Adjust scroll if selection is out of view
        if self.current_selection < self.scroll_offset:
            self.scroll_offset = self.current_selection
        elif self.current_selection >= self.scroll_offset + visible_height:
            self.scroll_offset = self.current_selection - visible_height + 1

        # Draw visible runs
        for idx in range(visible_height):
            run_idx = idx + self.scroll_offset
            if run_idx >= len(runs):
                break

            run = runs[run_idx]

            # Format run data
            build_num = run.get('buildNumber', 'N/A')[:15]
            status = run.get('status', 'unknown')[:12]
            result = run.get('result', 'N/A')[:12]
            start_time = run.get('startTime', '')
            if start_time:
                try:
                    dt = datetime.fromisoformat(start_time.replace('Z', '+00:00'))
                    start_time = dt.strftime('%Y-%m-%d %H:%M')
                except:
                    start_time = start_time[:20]
            branch = run.get('sourceBranch', '')
            if branch.startswith('refs/heads/'):
                branch = branch[11:]
            branch = branch[:30]

            line = f"{run_idx+1:<5} {build_num:<15} {status:<12} {result:<12} {start_time:<20} {branch:<30}"

            # Apply colors and highlight selection
            y_pos = 4 + idx
            if run_idx == self.current_selection:
                self.stdscr.addstr(y_pos, 0, line[:width-1], curses.color_pair(1))
            else:
                color = self.get_status_color(status, result)
                self.stdscr.addstr(y_pos, 0, line[:width-1], curses.color_pair(color))

        # Footer with scroll indicator
        footer = f"Showing {self.scroll_offset + 1}-{min(self.scroll_offset + visible_height, len(runs))} of {len(runs)}"
        self.stdscr.addstr(height - 1, 0, footer[:width-1], curses.color_pair(5))

        self.stdscr.refresh()

    def draw_failures_list(self, failures: List[Dict[str, Any]], build_number: str,
                          test_selection: int, test_scroll: int):
        """Draw the list of failed tests with selection support."""
        self.stdscr.clear()
        height, width = self.stdscr.getmaxyx()

        # Header
        header = f"Failed Tests for Build {build_number}"
        self.stdscr.addstr(0, 0, header[:width-1], curses.color_pair(5) | curses.A_BOLD)
        self.stdscr.addstr(
            1, 0,
            "Use arrow keys, Enter to download logs, Q/Esc to return"[:width-1],
            curses.color_pair(5)
        )

        if not failures:
            self.stdscr.addstr(3, 0, "No failed tests found!", curses.color_pair(2))
            self.stdscr.refresh()
            return

        # Calculate visible range
        visible_height = height - 5  # Account for header and footer

        # Draw visible failures
        y_pos = 3
        for idx in range(visible_height):
            test_idx = idx + test_scroll
            if test_idx >= len(failures):
                break

            failure = failures[test_idx]
            test_line = f"{failure['run']}: {failure['test']}"

            # Highlight selection
            if test_idx == test_selection:
                self.stdscr.addstr(y_pos, 0, test_line[:width-1], curses.color_pair(1))
            else:
                self.stdscr.addstr(y_pos, 0, test_line[:width-1], curses.color_pair(3))

            y_pos += 1

        # Summary footer
        total_failures = len(failures)
        summary = f"Showing {test_scroll + 1}-{min(test_scroll + visible_height, total_failures)} of {total_failures} failed tests"
        self.stdscr.addstr(height - 1, 0, summary[:width-1], curses.color_pair(5) | curses.A_BOLD)

        self.stdscr.refresh()

    def select_failed_test(self, failures: List[Dict[str, Any]], build_number: str) -> Optional[Dict[str, Any]]:
        """Handle failed test selection with arrow keys."""
        test_selection = 0
        test_scroll = 0

        if not failures:
            self.draw_failures_list(failures, build_number, 0, 0)
            self.stdscr.getch()
            return None

        height, _ = self.stdscr.getmaxyx()
        visible_height = height - 5

        while True:
            # Adjust scroll if selection is out of view
            if test_selection < test_scroll:
                test_scroll = test_selection
            elif test_selection >= test_scroll + visible_height:
                test_scroll = test_selection - visible_height + 1

            self.draw_failures_list(failures, build_number, test_selection, test_scroll)

            key = self.stdscr.getch()

            if key == curses.KEY_UP:
                test_selection = max(0, test_selection - 1)
            elif key == curses.KEY_DOWN:
                test_selection = min(len(failures) - 1, test_selection + 1)
            elif key == ord('\n') or key == curses.KEY_ENTER:
                return failures[test_selection]
            elif key == ord('q') or key == ord('Q') or key == 27:  # 27 is ESC
                return None

    def select_run(self, runs: List[Dict[str, Any]], pipeline_name: str) -> Optional[Dict[str, Any]]:
        """Handle run selection with arrow keys."""
        while True:
            self.draw_runs_list(runs, pipeline_name)

            key = self.stdscr.getch()

            if key == curses.KEY_UP:
                self.current_selection = max(0, self.current_selection - 1)
            elif key == curses.KEY_DOWN:
                self.current_selection = min(len(runs) - 1, self.current_selection + 1)
            elif key == ord('\n') or key == curses.KEY_ENTER:
                return runs[self.current_selection]
            elif key == ord('q') or key == ord('Q'):
                return None


def main(stdscr):
    """Main entry point for the curses UI."""
    try:
        # Initialize Azure DevOps connection
        azdo = AzDoConnection()

        # Find RunRegression pipeline
        pipeline_name = "RunRegression"
        pipeline_id = azdo.find_pipeline_by_name(pipeline_name)

        if pipeline_id is None:
            stdscr.addstr(0, 0, f"Error: Pipeline '{pipeline_name}' not found!")
            stdscr.addstr(1, 0, "Press any key to exit...")
            stdscr.getch()
            return

        # Get pipeline runs
        stdscr.addstr(0, 0, "Loading pipeline runs...")
        stdscr.refresh()

        runs = azdo.get_pipeline_runs(pipeline_id)

        if not runs:
            stdscr.addstr(0, 0, "No runs found for this pipeline!")
            stdscr.addstr(1, 0, "Press any key to exit...")
            stdscr.getch()
            return

        # Initialize UI
        ui = CursesUI(stdscr)

        # Main loop
        while True:
            selected_run = ui.select_run(runs, pipeline_name)

            if selected_run is None:
                break  # User quit

            # Show loading message
            stdscr.clear()
            stdscr.addstr(0, 0, "Loading test failures...")
            stdscr.refresh()

            # Get failed tests
            build_id = selected_run['id']
            build_number = selected_run.get('buildNumber', str(build_id))
            failures = azdo.get_failed_tests(build_id)

            # Test selection loop
            while True:
                selected_test = ui.select_failed_test(failures, build_number)

                if selected_test is None:
                    break  # User went back

                # Show downloading message
                stdscr.clear()
                stdscr.addstr(0, 0, f"Downloading logs for: {selected_test['test']}")
                stdscr.addstr(1, 0, "Please wait...")
                stdscr.refresh()

                # Download logs
                try:
                    output_dir = azdo.download_test_logs(
                        selected_test['run_id'],
                        selected_test['result_id'],
                        build_id,
                        selected_test['test']
                    )

                    # Show success message
                    stdscr.clear()
                    stdscr.addstr(0, 0, "Logs downloaded successfully!", curses.color_pair(2))
                    stdscr.addstr(1, 0, f"Location: {output_dir}")
                    stdscr.addstr(3, 0, "Press any key to continue...")
                    stdscr.refresh()
                    stdscr.getch()

                except Exception as e:
                    # Show error message
                    stdscr.clear()
                    stdscr.addstr(0, 0, "Error downloading logs:", curses.color_pair(3))
                    stdscr.addstr(1, 0, str(e)[:stdscr.getmaxyx()[1] - 1])
                    stdscr.addstr(3, 0, "Press any key to continue...")
                    stdscr.refresh()
                    stdscr.getch()

    except Exception as e:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Error: {str(e)}")
        stdscr.addstr(1, 0, "Press any key to exit...")
        stdscr.refresh()
        stdscr.getch()


if __name__ == "__main__":
    try:
        curses.wrapper(main)
    except KeyboardInterrupt:
        print("\nExited by user")
        sys.exit(0)
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
